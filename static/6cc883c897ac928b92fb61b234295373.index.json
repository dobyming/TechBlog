{"index":"{\"keys\":[{\"path\":[\"title\"],\"id\":\"title\",\"weight\":1,\"src\":\"title\",\"getFn\":null},{\"path\":[\"body\"],\"id\":\"body\",\"weight\":1,\"src\":\"body\",\"getFn\":null}],\"records\":[{\"i\":0,\"$\":{\"0\":{\"v\":\"resume\",\"n\":1},\"1\":{\"v\":\"# 김다민(Damin Kim)\\r\\n\\r\\n<div align=\\\"right\\\"><sub><i>Last updated: 2023.07.09</i></sub></div>\\r\\n\\r\\n## 안녕하세요, 끊임없이 도전하는 개발자 김다민입니다.\\r\\n\\r\\n웹 브라우저의 세계가 커짐에 따라 상상을 현실로 실현할 수 있는 프론트엔드 분야를 애정합니다. 늘 **사용자 관점에서 프로젝트를 바라보려 노력**하고 **UX를 높일 수 있는 방향성을 끊임없이 고민**하는데 큰 재미를 느끼고 있습니다.\\r\\n\\r\\n**다양한 의견을 적극적으로 수용하고 끊임없는 도전정신으로 문제 해결에 주력**하며 꾸준한 성장을 도모하는 프론트엔드 개발자로 함께 하고 싶습니다.\\r\\n\\r\\n# Experiences\\r\\n## 🚚 Hanjin Co Ltd. - Project Team\\r\\n*DevOps Frontend Developer as Intern Seoul, South Korea – (Aug 2022 - Dec 2022)* \\r\\n\\r\\n### Projects\\r\\n애자일 방식의 차세대 간선 시스템 프로젝트 - 프론트엔드 파트 개선 및 개발 작업 수행 \\r\\n(***Stack : eXbuilder6, JavaScript(ES6), React, Docker, Redis, Kafka***)\\r\\n\\r\\n- **[feature] 유저 Role에 따른 버튼(기능) 권한 부여 작업**\\r\\n    - 로그인 시, JSON 값으로 부여되는 권한 코드에 따른 버튼(기능) 권한 이벤트 함수를 구현하고 전체 페이지에 적용\\r\\n- **[feature] 미아편명 팝업 페이지 구현**\\r\\n    - 백엔드 개발자와 페어코딩을 통해, 팝업 버튼을 클릭 시 API가 호출되면서 팝업화면에 대체 가능한 편명을 조회 및 저장하는 기능 구현\\r\\n    - UX를 고려하여, 선택된 대체 편명이 없을때 저장 시도 시 alert 메시지를 띄우는 작업 수행\\r\\n    - 대체할 편명과 대체될 편명이 똑같을 경우 팝업창이 그대로 닫히지 않고 focus될 수 있도록 validation check 기능 구현\\r\\n- **[feature] 요율, 터미널별 권역 페이지 구현**\\r\\n    - 백엔드 개발자와 페어코딩을 통해 각 터미널 별 비용을 CRUD 할 수 있는 기능과 전체적인 UI mock-up 진행\\r\\n    - 엑셀로 업무를 수행하는 본사팀의 업무 관례를 고려하여, SheetJS를 통해 한번에 요율과 권역을 시스템에 업로드 및 저장할 수 있는 기능 구현\\r\\n- **[Improvement] 조업사 모바일 플랫폼 UX 증진 작업**\\r\\n    - 상/하차 페이지에서 (상하차작업 리스트) 운행완료 건들을 색깔로서 구분될 수 있도록 작업 수행\\r\\n    - 운행이 완료된 작업들은 리스트의 맨밑으로 이동될 수 있도록 sort 수행\\r\\n    - 조업사의 하루 기준에 맞춰 달력에 default로 날짜가 setting 될 수 있도록 Moment.js를 통해 작업 수행 (하루 기준 : 당일 10:00 AM ~ d+1 9:59 AM).\\r\\n\\r\\n# Side Projects\\r\\n[이 사이트](https://url.kr/qlcrmf)로 접속 시, 저의 Side Project를 확인하실 수 있습니다.\\r\\n\\r\\n# Skills\\r\\n### Front-End\\r\\n- HTML, CSS, JavaScript, TypeScript, Emotion\\r\\n- NPM, WebPack\\r\\n- React, React-Native, GatsbyJS, GraphQL\\r\\n\\r\\n### Back-End & Server\\r\\n- Python\\r\\n- NodeJS, ExpressJS\\r\\n- Nginx, Axios, Ajax\\r\\n- MySQL\\r\\n\\r\\n### DevOps\\r\\n- Firebase, Firebase Auth, Github Pages\\r\\n- AWS (EC2, S3, CodePipeline)\\r\\n\\r\\n### Collaboration\\r\\n- VS Code, IntelliJ, PyCharm\\r\\n- Git, Github, AWS CodeCommit\\r\\n- Google Space, Redmine\\r\\n\\r\\n# Education\\r\\n## 인하대학교(Inha University) \\r\\n*컴퓨터공학과(Bachelor of Computer Engineering) - (Mar 2020 ~ Feb 2023)*\",\"n\":0.053}}},{\"i\":1,\"$\":{\"0\":{\"v\":\"Gatsby - GraphQL로 query 요청하기\",\"n\":0.447},\"1\":{\"v\":\"\\r\\n## GraphQL이란?\\r\\nGraphQL은 페이스북에서 개발한 **쿼리 언어**입니다.\\r\\n각각의 엔드포인트에서 고정된 데이터를 받을 수 있는 Rest API와는 다르게 GraphQL은 <span style=\\\"color:red\\\">**단일 엔드포인트**</span>에서 원하는 데이터만을 받을 수 있다는 장점을 가지고 있습니다.\\r\\n\\r\\n정적 웹사이트의 콘텐츠 데이터를 관리하는데 있어 GraphQL로 진행할 수 있습니다. \\r\\n\\r\\n## Gatsby에서 GraphQL을 사용하는 방법\\r\\n\\r\\n그럼 Gatsby에서 GraphQL로 query로 요청해서 웹사이트로 값을 불러오는 방법에 대해서 알아보겠습니다. \\r\\n\\r\\n우선 `pages` 폴더 내에 `info.tsx`를 선언합니다. \\r\\n\\r\\n```tsx\\r\\nimport React, { FunctionComponent } from 'react'\\r\\nimport { graphql } from 'gatsby'\\r\\nimport Text from 'components/Text'\\r\\n\\r\\ntype InfoPageProps = {}\\r\\n\\r\\nconst InfoPage: FunctionComponent<InfoPageProps> = function () {\\r\\n  return (\\r\\n    <div>\\r\\n      <Text text=\\\"Hello\\\" />\\r\\n    </div>\\r\\n  )\\r\\n}\\r\\n\\r\\nexport default InfoPage\\r\\n```\\r\\n일반적인 컴포넌트에서는 변수로서 정의가 불가능하고, **StaticQuery**라는 기능을 통해 정의가 가능합니다. pages 폴더 내부에 있는 컴포넌트에서는 다음과 같이 Query를 정의하고 요청할 수 있습니다.\\r\\n\\r\\n```tsx\\r\\nimport React, { FunctionComponent } from 'react'\\r\\nimport { graphql } from 'gatsby'\\r\\nimport Text from 'components/Text'\\r\\n\\r\\ntype InfoPageProps = {}\\r\\n\\r\\nconst InfoPage: FunctionComponent<InfoPageProps> = function () {\\r\\n  return (\\r\\n    <div>\\r\\n      <Text text=\\\"Hello\\\" />\\r\\n    </div>\\r\\n  )\\r\\n}\\r\\n\\r\\nexport default InfoPage\\r\\n\\r\\n// query 요청 부 \\r\\nexport const metadataQuery = graphql`\\r\\n  {\\r\\n    site {\\r\\n      siteMetadata {\\r\\n        title\\r\\n        description\\r\\n        author\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n`\\r\\n```\\r\\n\\r\\n`metadataQuery` 변수에 요청한 Query를 요청 시, 요청에 대한 응답 값은 `InfoPage` 컴포넌트의 Props로 전달해줍니다. 마지막으로 `InfoPage` 컴포넌트의 매개변수로 값을 불러오면서 Gatsby에서 GraphQL을 통한 Query 요청 작업이 마무리 됩니다. \\r\\n```tsx\\r\\nimport React, { FunctionComponent } from 'react'\\r\\nimport { graphql } from 'gatsby'\\r\\nimport Text from 'components/Text'\\r\\n\\r\\n// 요청한 Query의 데이터 구조에 따라 type을 지정 \\r\\ntype InfoPageProps = {\\r\\n  data: {\\r\\n    site: {\\r\\n      siteMetadata: {\\r\\n        title: string\\r\\n        description: string\\r\\n        author: string\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n// 매개변수로 요청한 Query를 Props로 전달 \\r\\nconst InfoPage: FunctionComponent<InfoPageProps> = function ({\\r\\n  data: {\\r\\n    site: {\\r\\n      siteMetadata: { title, description, author },\\r\\n    },\\r\\n  },\\r\\n}) {\\r\\n  return (\\r\\n    <div>\\r\\n      <Text text={title} />\\r\\n      <Text text={description} />\\r\\n      <Text text={author} />\\r\\n    </div>\\r\\n  )\\r\\n}\\r\\n\\r\\nexport default InfoPage\\r\\n\\r\\nexport const metadataQuery = graphql`\\r\\n  {\\r\\n    site {\\r\\n      siteMetadata {\\r\\n        title\\r\\n        description\\r\\n        author\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n`;\\r\\n```\\r\\n\\r\\n이와 같이 Gatsby에서 GraphQL을 통해 데이터를 요청하고 응답받는 과정을 수행할 수 있습니다. \",\"n\":0.058}}},{\"i\":2,\"$\":{\"0\":{\"v\":\"JavaScript - 함수\",\"n\":0.577},\"1\":{\"v\":\"### 함수\\r\\n\\r\\n-**함수 선언식 vs 함수 표현식 차이**\\r\\n\\r\\n```jsx\\r\\nconsole.log(helloDelcare()); // '안녕하세요 함수 선언식입니다'\\r\\nconsole.log(hello); // error : 'hello is not a function'\\r\\n\\r\\nfunction helloDelcare() {\\r\\n\\treturn '안녕하세요 함수 선언식입니다'\\r\\n}\\r\\n\\r\\nlet hello = function helloRepresent() {\\r\\n\\treturn '안녕하세요 함수 표현식 입니다.'\\r\\n}\\r\\n```\\r\\n\\r\\n1) 함수 선언식: **Hoisting**(쉽게 말하면 밑에서 선언한 함수를 코드의 상단에서 호출해도 출력이 이루어짐)이 일어나는 방식 \\r\\n\\r\\n2) 함수 표현식: **Hoisting**의 대상이 되지 않음 ⇒ 즉 `hello` 변수를 표현하면서 부터 함수가 생성되기 때문에, 상단에서 hello를 log로 찍으려고 하면 **에러**가 발생.\\r\\n→ 따라서 함수를 먼저 선언 후, 표현식에 선언된 변수를 호출해야 정상적으로 값을 찍을 수 있다. \\r\\n\\r\\n**-arrow function (함수 표현식을 간단히 표현하는 방법)**\\r\\n\\r\\n```jsx\\r\\nlet hello = () => {\\r\\n\\treturn '안녕하세요'\\r\\n}\\r\\n// '() =>' 표현과 동일한 예약어가 'function 함수명()' 이라고 생각하면 됌 \\r\\n```\\r\\n\\r\\n화살표 함수는 쉽게 생각하면 함수 표현식에서 keyword `function` **만 삭제**한 문법이라고 생각하면 된다. (역시 Hoisting의 대상이 아님)\\r\\n\\r\\n>-콜백함수\\r\\n```jsx\\r\\nfunction checkMood(mood) {\\r\\n\\tif (mood === \\\"good\\\") {\\r\\n\\t\\t// ...\\r\\n\\t\\tsing()\\r\\n\\t} else {\\r\\n\\t\\t// ...\\r\\n\\t\\tcry()\\r\\n\\t}\\r\\n}\\r\\n\\r\\nfunction cry() {\\r\\n\\tconsole.log('Action : CRY');\\r\\n}\\r\\n\\r\\nfunction sing() {\\r\\n\\tconsole.log('Action : SING');\\r\\n}\\r\\n\\r\\nfunction dance() {\\r\\n\\tconsole.log('Action: DANCE');\\r\\n}\\r\\n\\r\\ncheckMood(\\\"good\\\"); \\r\\n```\\r\\n\\r\\n기존 동작 방식\\r\\n\\r\\n1. `checkMood` 함수가 good이라는 매개변수를 전달 받는다.\\r\\n2. good이면 `sing` 함수를 호출해서 console 로그가 찍힌다.\\r\\n\\r\\n>**콜백함수의 등장 배경** \\r\\n만약 어떤 함수에서 특정 기능을 사용하고 싶은데, 일일이 body안에 메소드를 선언해줘야 한다면.. 코드 유지보수성이 매우 떨어진다.  \\r\\n따라서 만약 함수(`checkMood`) 파라미터에 함수(`sing` , `cry` , `dance`)를 넘겨주면 매개변수로는 **함수의 표현식** 처럼 작동하게 됩니다. \\r\\n\\r\\n```jsx\\r\\nfunction checkMood(mood,goodCallback,badCallback) {\\r\\n\\tif (mood === \\\"good\\\") {\\r\\n\\t\\t// ...\\r\\n\\t\\tgoodCallback()\\r\\n\\t} else {\\r\\n\\t\\t// ...\\r\\n\\t\\tbadCallback()\\r\\n\\t}\\r\\n}\\r\\n\\r\\nfunction cry() {\\r\\n\\tconsole.log('Action : CRY');\\r\\n}\\r\\n\\r\\nfunction sing() {\\r\\n\\tconsole.log('Action : SING');\\r\\n}\\r\\n\\r\\nfunction dance() {\\r\\n\\tconsole.log('Action: DANCE');\\r\\n}\\r\\n\\r\\ncheckMood(\\\"good\\\",sing,cry); \\r\\n```\\r\\n\\r\\n다음과 같이 구성한 코드를 콜백함수라고 합니다. 콜백함수는 비동기함수에서 중요한 개념으로 쓰입니다. \",\"n\":0.066}}},{\"i\":3,\"$\":{\"0\":{\"v\":\"Gatsby에서 페이지 라우팅 하는법\",\"n\":0.5},\"1\":{\"v\":\"\\r\\n## Gatsby에서 페이지 라우팅하기 \\r\\n\\r\\nGatsby에서 페이지간 라우팅 하는 방식은 2가지가 있습니다. \\r\\n\\r\\n첫번째는 `a` 태그를 활용하는 것입니다. pages 폴더 내에 선언된 파일들은 '/파일명'으로 페이지 간 이동이 가능합니다. \\r\\n하지만 React 기반으로 설계된 프레임워크인 Gatsby를 감히 매번 페이지 이동 시, refresh 되게 구현하면... 이걸로 왜 개발 하냐구요 (UX도 매우 저하되구요) \\r\\n\\r\\n\\r\\n## Gatsby Link API 활용하기 \\r\\n\\r\\nGatsby에서 제공하는 페이지 이동 API인  <span style=\\\"color:red\\\">Gatsby Link API</span>을 활용하여 페이지 간 라우팅을 구현할 수 있습니다. 이 API를 통해 페이지 이동을 구현하면 보다 더 높은 성능의 정적 사이트를 구현할 수 있습니다.\\r\\n\\r\\n### Usage\\r\\n```tsx\\r\\nimport { Link } from 'gatsby'\\r\\n<Link to=\\\"/info/\\\">To Info</Link>\\r\\n```\\r\\n기본적인 사용방법은 위와 같습니다. `Link`를 import 후, Link 태그의 to의 props로 이동할 페이지명을 적어주면 됩니다. \\r\\n\\r\\n해당 방식으로 구현 시, a 태그를 사용했을때보다 Link태그를 활용하여 페이지 간 라우팅 방식이 훨씬 더 매끄럽고 속도도 향상됨을 체감할 수 있을 것 입니다. \\r\\n\\r\\n그러면 우리는 왜 이럴 수 있는지에 대한 근거까지 알아봐야겠죠\\r\\n\\r\\n### Gatsby Link API의 성능상 이점\\r\\n궁극적인 근거는 Gatsby는 **Prefetch**를 통해서 페이지에서 사용할 리소스의 로딩 속도를 높일 수 있습니다. \\r\\n\\r\\n즉 Prefetch는 이와 같은 개념입니다. \\r\\n\\r\\n1. 페이지가 로드가 됌 -> 현재 로드된 페이지 내에서 사용되는 모든 링크 찾은 후 -> 각 링크의 페이지를 <span style=\\\"color:red\\\">미리</span> 로드 \\r\\n2. 즉 예를 들면, `index.tsx` 페이지 로드가 됨 -> 동시에 `Link` 태그를 찾음(`/info`) -> 이 페이지(`info`)를 미리 로드해둠 \\r\\n\\r\\n\",\"n\":0.071}}},{\"i\":4,\"$\":{\"0\":{\"v\":\"JavaScript - 동기와 비동기 처리\",\"n\":0.447},\"1\":{\"v\":\"\\r\\n## 동기와 비동기 (Synchronus , Asynchronus)\\r\\n이번 포스팅에선 자바스크립트의 2가지 동작 방식인 동기와 비동기처리에 대해서 다뤄\\r\\n보겠습니다.\\r\\n\\r\\n함수 3개를 호출했을때를 예로 들어보겠습니다.\\r\\n\\r\\n```jsx\\r\\nfunction taskA() {\\r\\n  console.log('Task A');\\r\\n}\\r\\nfunction taskB() {\\r\\n  console.log('Task B');\\r\\n}\\r\\nfunction taskC() {\\r\\n  console.log('Task C');\\r\\n}\\r\\n\\r\\n//함수 호출 \\r\\ntaskA();\\r\\ntaskB();\\r\\ntaskC();\\r\\n```\\r\\n\\r\\n함수 3개를 호출 시, 자바스크립트는 다음과 같이 작업을 할당합니다. 순서대로 함수를 호출하며 한개의 task가 끝날때까지 다음 task는 끼어들 수 없는 블로킹 방식으로 동기가 이루어집니다. \\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/a5298539-fe91-4a59-bd30-0f69822ad327/image.PNG)\\r\\n\\r\\n## 동기 처리의 문제점 \\r\\n![](https://velog.velcdn.com/images/damin1025/post/fb33ffa5-fbc4-42e0-8d4a-966a84597e2c/image.PNG)\\r\\n\\r\\n🤔 작업 시간이 긴 task를 처리할때 문제가 발생하게 된다.프론트는 속도가 생명이지 않나…? \\r\\n\\r\\n**멀티 스레드**로 방식으로 처리하면 되지 않나요?\\r\\n⇒ OS 상 생각은 ok. 하지만 자바스크립트는 **Single Thread**로 동작합니다. \\r\\n\\r\\n그래서 동기처리 대신 **비동기 처리** 개념이 필요해지게 됩니다.\\r\\n\\r\\n## 비동기 처리\\r\\n![](https://velog.velcdn.com/images/damin1025/post/57548644-48a6-4b56-8277-cb53ddac1f69/image.PNG)\\r\\n\\r\\n🤔 논 블로킹 방식이면 작업이 어떻게 끝나고 처리되는지.. 중구난방 아닐까요?\\r\\n→ **콜백 함수**를 활용합니다. \\r\\n\\r\\n대표적인 콜백 함수는 `setTimeout()` 으로, 코드를 바로 실행하지 않고 몇초 기다렸다가 다음 함수를 실행하는 방식으로 순서가 중구난방일지 염려되는 부분을 해결할 수 있습니다. \\r\\n\\r\\n```jsx\\r\\nfunction taskA() {\\r\\n\\tsetTimeout(() => {\\r\\n\\t\\tconsole.log('A Task End');\\r\\n\\t}, 2000); // 다음 함수 실행까지 2초 기다려줌 \\r\\n}\\r\\n\\r\\ntaskA();\\r\\nconsole.log('코드 끝');\\r\\n```\\r\\n---\\r\\n\\r\\n실행 결과\\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/bd013054-c63e-45d6-aea2-2a94361d7326/image.gif)\\r\\n\\r\\n## JS Engine\\r\\nJS Engine 기본 구성\\r\\n<br/>\\r\\n-Heap : 메모리 할당<br/>\\r\\n-**Call Stack** : 코드 실행\\r\\n\\r\\n### Call Stack 동기 작동방식\\r\\n\\r\\n항상 Main context가 먼저 stack에 push 됌. 그리고 선언한 함수 순서대로 Call Stack에 push되고, 작업이 끝나면 pop이 이루어짐.\\r\\n\\r\\n### 비동기 작동 방식\\r\\n여기서 `setTimeout()` 은 대표적인 **비동기 함수**인데, 만약 동기처리 방식 그대로 적용한다면 call stack에 3초 머물렀다가 콜백함수 `cb`를 호출하게 되는데 이와 같이 수행한다면 동기 처리 방식과 비동기 처리 방식의 차이점이 사라지게 됩니다.\\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/359c37e2-d6df-4195-af7d-3cf8d7011385/image.PNG)\\r\\n\\r\\n따라서 해당 비동기 함수는 비동기 처리를 위해, Web APIs에 3초동안 기다리면서 `asyncAdd()` 함수가 실행되면서 pop되면서 종료되고\\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/18c5b0e0-04d0-4a46-8beb-b5106cdac240/image.PNG)\\r\\n\\r\\n\\r\\n3초 기다린 `setTimeout()`은 제거가 되면서 콜백함수 `cb`를 콜백 큐에 push합니다.\\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/81ed6192-8b10-4789-ace7-ec3b9fc7b30e/image.PNG)\\r\\n\\r\\nEvent Loop을 통해 cb함수는 call stack로 push됩니다. \\r\\n\\r\\n이때 Event Loop는 Main Context를 제외한 다른 실행할 함수들이 Call stack에 존재하는지 계속해서 check합니다. 만약 수행할 함수가 콜백함수밖에 없다면, 그제서야 콜백함수를 Call Stack에 push하는 방식인거죠. \\r\\n\\r\\n그렇게 콜백함수를 수행하고 pop 후, Main Context도 제거되면서 비동기 작업이 완료가 됩니다. \\r\\n\\r\\n### 비동기 처리 방식의 문제점\\r\\n\\r\\n⇒ 만약 불러야 할 콜백함수를 메소드 내에서 계속 선언하게 된다면 **콜백지옥**을 야기합니다. 이는 이제 ES6+ 문법 중 `Promise` 객체 와 `async()-await()` 로 해결할 수 있습니다.\",\"n\":0.057}}},{\"i\":5,\"$\":{\"0\":{\"v\":\"Redux Toolkit - useDispatch로 state rasie하기\",\"n\":0.408},\"1\":{\"v\":\"## state를 useDispatch로 보내기 \\r\\n\\r\\n이전 포스팅에서 Redux toolkit으로 store를 셋팅을 했다면, 실제로 이제 각 컴포넌트에서 수행할 리듀서 함수를 import하여 사용하는 방법에 대해서 알아보도록 하겠습니다. \\r\\n\\r\\n\\r\\n## 순서\\r\\n**1. 컴포넌트에 알맞는 리듀서 함수를 import하기**\\r\\n\\r\\n해당 포스팅에서 todoList App의 핵심적인 기능인 **할일을 추가** 하는 기능을 수행하는 컴포넌트에 알맞는 리듀서 함수를 import 해보겠습니다. \\r\\n\\r\\nreducer slice 에 `addTodo()` 리듀서 함수를 구현했으므로, 해당 함수를 import 해야 할 것입니다. \\r\\n\\r\\n```jsx\\r\\nimport { addTodo } from '../redux/slices/todoSlice';\\r\\n```\\r\\n\\r\\n`slices` 에 리듀서 함수들을 export했기 때문에 import가 가능합니다.\\r\\n\\r\\n#### **2. state를 raise하기 하기** \\r\\n\\r\\n부모 컴포넌트 store에서 모든 state를 바꾸기 때문에 state를 바꾼다는 전달하는 매개체가 필요합니다. 이 매개체는 `useDispatch()` 훅으로 전달할 수 있습니다. \\r\\n\\r\\n```jsx\\r\\nimport { useDispatch } from 'react-redux';\\r\\n\\r\\n// 컴포넌트 내에 작성합니다. \\r\\nconst dispatch = useDispatch(); \\r\\n```\\r\\n`useDispatch()` 를 import합니다. \\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/a1626d25-39a9-448f-a5fb-6a20d073bf99/image.PNG)\\r\\n\\r\\n그리고 `dispatch` 함수 내부에 위에서 import한 리듀서 함수를 trigger합니다. 이와 같은 process로 리듀서 함수로 state를 raise할 수 있습니다. \",\"n\":0.088}}},{\"i\":6,\"$\":{\"0\":{\"v\":\"CORS에 대해서 알아보자\",\"n\":0.577},\"1\":{\"v\":\"### Origin 이란?\\r\\n\\r\\n아래와 같이 사이트들이 있다고 가정해보겠습니다. \\r\\n\\r\\n```bash\\r\\nhttp://localhost:8000\\r\\nhttps://api.alazierplace.com:3000/api/\\r\\nhttps://alazierplace.com/2019/05/data-driven-testing-how-we-went-from-150-test-cases-to-1/\\r\\n```\\r\\n\\r\\nscheme(http,https) + IP 주소 또는 도메인 + :포트넘버 ⇒ 해당 구성을 Origin 이라고 칭합니다. \\r\\n\\r\\nJS의 Script 파일이 HTTP에 API 요청을 할때, 서버에 요청을 보내기 전에 Origin 정보를 헤더에 저장합니다. \\r\\n\\r\\n### CORS 이슈가 중요한 이유\\r\\n\\r\\nOrigin이 다른 헤더값을 계속해서 요청하게 되면, 악의적인 스크립트로 인해 보안성이 취약해지고, 유저와 사이트에 해가 될 수 있습니다.\\r\\n특히 `same-orign policy` 는 클라이언트 쪽에서 더 중요하게 다뤄지는 부분이기 때문에 더욱이 CORS를 따져줘야 합니다. (*`same-origin-policy` : 없는 도메인 값 또는 포트를 요청하는 행위) \\r\\n\\r\\n### CORS란?\\r\\n\\r\\nCross-Origin Resource Sharing의 약자로, W3C가 제안한 웹 표준으로 클라이언트가 실행되는 브라우저에서 origin값을 접근할 수 있도록 가능케 하는 개념입니다.\\r\\n\\r\\n![Request/Response cycle for a CORS Request](https://i0.wp.com/alazierplace.com/wp-content/uploads/2019/06/CORS-flow.png?resize=833%2C406&ssl=1)\\r\\n\\r\\nRequest/Response cycle for a CORS Request\\r\\n\\r\\n**<실행 순서>**\\r\\n\\r\\n- JS 클라이언트가 AJAX call을 시작함\\r\\n- 브라우저가 (실제 클라이언트가 서버에 요청을 보내기전에) request를 intercept하여 `pre-flight` 요청을 보냄\\r\\n- 서버는 `pre-flight` 에 대한 response에 CORS configuration을 담은 HTTP 헤더를 브라우저에 보냄\\r\\n- CORS가 verify되면 실제 클라이언트가 request한 값을 서버에 보내게 됌\\r\\n- 서버는 요청한 response값을 JS Client에 보내줌\\r\\n\\r\\n******************pre-flight request?****************** \\r\\n\\r\\n- HTML 옵션을 request 하는 것으로, 이에 대한 response로는 CORS configuration(구성 파일)을 명시하는 HTTP 헤더\\r\\n- 한번만 보내지고, 브라우저에 의한 캐싱이 처리된다.\\r\\n- 매번 CORS request가 보내지는건 아니고 다음과 같은 조건에 부합할때 보내진다.\\r\\n    - `HEAD`, `POST`, `GET` 이외의 HTTP 메소드를 request 할때\\r\\n    - Content-type request에 application/x-www-form-urlencoded, multipart/form-data 및 text/plain 이외의 값이 있을때\\r\\n    - 요청이 Accept, Accept-Language 및 Content-Language 이외의 헤더를 설정할때\\r\\n\\r\\n### 그래서 왜 이렇게까지 CORS를 따져야 할까?\\r\\n\\r\\nJavaScript는 돌아갈 수 있는 실행환경이 다양하기 때문입니다. \\r\\n\\r\\n특히 JavaScript 같은 경우는, 네트워크를 통해 브라우저의 형태로 사용자에게 제공됩니다. 그리고 웹뿐만 아니라 모바일 웹에서도 접근이 가능하기 때문에 실행환경 역시 다양해집니다. \\r\\n\\r\\n브라우저는 로그인 정보, 쿠키, 세션등 민감한 정보들을 담고 있고 이에 대한 철저한 규제가 필요할 것입니다. \\r\\n\\r\\n비유해서 말하면.. 이상한 사람이 맛있는거 사준다고 해도 쫓아가면 안된다 를 표현한 개념이 CORS라고 볼 수 있습니다. JavaScript 클라이언트에서 이에 대한 빡센 규정이 필요하죠.\",\"n\":0.059}}},{\"i\":7,\"$\":{\"0\":{\"v\":\"Redux Toolkit으로 React Native Todo앱 구조 잡아보기\",\"n\":0.378},\"1\":{\"v\":\"## 🔎 동기\\r\\n리액트 프로젝트를 진행하면서 가장 챌린지 했던 부분은 **state관리**였습니다. \\r\\n\\r\\n각각의 컴포넌트는 state를 관리하고 있지만, 컴포넌트 파일이 방대해지고 props로 전달해야 되는 부분이 많아지게 되면 state 관리가 복잡해져서 굉장히 설계에 어려움을 겪었던 경험이 있었습니다.. 😥 \\r\\n\\r\\n하지만 Redux는 이러한 부분을 완화시켜줄 수 있는 tool로, store로 모든 state를 관리할 수 있습니다. 따라서 React Native로 진행하고 있는 Todo App의 data state의 관리를 `Redux Toolkit` 을 통해 로직을 구현하고자 합니다.  \\r\\n\\r\\n## 🛒 순서\\r\\n전체적인 구조는 어떠한 이벤트가 발생 시, 해당 Action을 Dispatcher에 전달하여 Reducer 함수들을 통해 해당하는 Action의 state를 raise하여 반환합니다. 그리고 store 내부 state가 update 되면 그 state를 컴포넌트에 전달하여 리렌더링이 진행됩니다. \\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/441bb55f-8efc-4bb3-a07a-6040a8a059a7/image.png)\\r\\n\\r\\n\\r\\n다음 CLI 명령어로 `Redux Toolkit`을 생성할 수 있습니다.\\r\\n```bash\\r\\nnpm install @reduxjs/toolkit react-redux\\r\\n```\\r\\n\\r\\n### 1. configureStore를 사용하여 Redux Store 생성\\r\\n```jsx\\r\\nimport { configureStore } from \\\"@reduxjs/toolkit\\\";\\r\\nimport todoReducer from './slices/todoSlice';\\r\\n\\r\\nexport const store = configureStore({\\r\\n    reducer:{\\r\\n        todo: todoReducer //생성한 reducer를 Store에 등록\\r\\n    }\\r\\n});\\r\\n```\\r\\n\\r\\n### 2. React 컴포넌트에 Redux Store 제공 순서\\r\\n제 프로젝트의 `App` 컴포넌트 아래 컴포넌트인 `MainScreen` 컴포넌트에 data 및 state를 공급하기 위해 다음과 같이 `Provider` 컴포넌트에 `store`를 props로 전달해야합니다. \\r\\n\\r\\n```jsx\\r\\nimport { Provider } from 'react-redux';\\r\\nimport {store} from './redux/store';\\r\\nimport MainScreen from './screens/MainScreen';\\r\\n\\r\\nexport default function App() {\\r\\n  return (\\r\\n    <Provider store={store}>\\r\\n      <MainScreen/>\\r\\n    </Provider>\\r\\n  );\\r\\n}\\r\\n```\\r\\n\\r\\n⚠ 이때 생성한 store는 **내장 모듈이 아니기 때문에** `{ }` 로 감싸서 모듈을 import 하는것에 주의합니다.\\r\\n  \\r\\n\\r\\n### 3. createSlice로 Redux slice reducer 생성\\r\\n`createSlice`를 활용하여 상태관리 함수 로직을 구현합니다. \\r\\n제 프로젝트에는 add,update,delete에 관한 상태관리함수가 필요하기 때문에 `reducer`로 정의합니다. \\r\\n\\r\\n```jsx\\r\\nconst todoSlice = createSlice({\\r\\n  name: \\\"todo\\\", \\r\\n  initialState: {\\r\\n        currentId: 4,\\r\\n        todos: [],\\r\\n    }, //초기 state 정의\\r\\n  reducers: {\\r\\n    //state functions(add,delete,update 로직 구현 부)\\r\\n  },\\r\\n});\\r\\nexport default todoSlice.reducer; \\r\\n```\\r\\n\\r\\n### 4. useSelector, useDispatch로 데이터 읽고 state raise하기\\r\\n\\r\\n`useSelector`로 `store`에서 데이터를 읽어줍니다.\\r\\n`useDispatch`로 dispatch함수를 가져오고 필요에 따라 action을 dispatch합니다. (action을 dispatch한다 = event를 trigger한다.)\\r\\n\\r\\n해당 부분은 다음 포스팅에서 더 자세히 다루겠습니다.\\r\\n\\r\\n## 🌌 리듀서 함수 구체화하기\\r\\n`createSlice`로 Redux slice Reducer를 생성했다면 각각의 상태관리함수 (add,update,delete)에 대해서 구현을 진행하겠습니다. \\r\\n\\r\\n### 1. addTodo()\\r\\n![](https://velog.velcdn.com/images/damin1025/post/cfab0e3f-ee60-49c1-983f-a88b9cbec230/image.PNG)\\r\\n\\r\\n현재 state의 할일 배열값을 받을 `todos`에 값을 push해주는 로직으로 구현할 수 있습니다. \\r\\n\\r\\n### 2. updateTodo()\\r\\n![](https://velog.velcdn.com/images/damin1025/post/8aa630c4-94c4-4ca9-a5e0-4fb4b7f5cc05/image.PNG)\\r\\n\\r\\nupdate(할일 종료)했다는 index를 따기 위해서 `item` 변수에 `findIndex()`로 상태가 변화한 index를 담습니다. 그리고 삼항연산자를 통해 todo -> done 으로 state를 바꿔주고, `todos` 배열에서 제거한 값을 배열에 push합니다. \\r\\n\\r\\n\\r\\n### 3. deleteTodo()\\r\\n![](https://velog.velcdn.com/images/damin1025/post/0bc7ec31-156b-4bff-9360-865913c271e7/image.PNG)\\r\\n\\r\\n`x` 버튼을 삭제하는 로직입니다. 전체적인 흐름은 `updateTodo()` 와 동일합니다.\\r\\n\\r\\n\\r\\n### reducer 함수 export 하기 \\r\\n마지막으로 해당 reducer함수들을 외부 컴포넌트에서도 사용할 수 있도록 export하는 작업으로 마무리합니다.\\r\\n```jsx\\r\\nexport const { addTodo, updateTodo, deleteTodo } = todoSlice.actions;\\r\\n```\\r\\n\",\"n\":0.052}}},{\"i\":8,\"$\":{\"0\":{\"v\":\"Gatsby란?\",\"n\":1},\"1\":{\"v\":\"### Gatsby에 대해 설명하기 전에..\\r\\n[Gatsby](https://www.gatsbyjs.com/)는 React 기반으로 설계된 프레임워크입니다. 이때 Gatsby를 알기전에 **JAM Stack**이라는 용어에 대해서 알아야 할 필요가 있습니다. \\r\\n\\r\\n블로그나 포트폴리오와 같이 **정적 페이지**를 개발해야 할 때에 활용됩니다. 정적 사이트 생성기인 Gatsby를 시작하기 전에 <span style=\\\"color:red\\\">JAM Stack</span>에 대해 먼저 알아봅시다. \\r\\n\\r\\n\\r\\n### JAM Stack이란?\\r\\n\\r\\nJAM Stack은 더 빠르고, 안전하며, 스케일링하기 쉬운 웹을 만들기 위해 디자인된 아키텍처입니다. \\r\\n\\r\\n즉 JAM Stack은 JavaScript, API, MarkUp Stack의 약자로, 자바스크립트와 API, HTML이나 CSS 등을 칭하는 MarkUp으로 이루어진 웹 구성 방법입니다.\\r\\n\\r\\n이름에 있는 그대로 저 3가지의 기술을 통해 홈페이지를 만든다는 것인데, 그럼 기존 웹 사이트와는 어떤 차이점이 있을까요?\\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/0b81fb8f-ec23-40fc-bc72-93a1a3a4af89/image.png)\\r\\n\\r\\n\\r\\n기존 웹 사이트의 방식은 대부분 서버에서 데이터베이스 또는 CMS(Content Management System)로부터 추출한 데이터를 프론트엔드에 뿌려주는 방식입니다. 이는 클라이언트에 데이터를 보여주기 위해서 많은 절차를 거쳐야만 하기 때문에 구조가 복잡합니다.\\r\\n\\r\\n하지만 JAM Stack을 사용한 방식은 기존 웹사이트의 방식과 다르게 절차가 매우 간단합니다.\\r\\n\\r\\n각종 마크업 요소와 다양한 API를 통해 만든 정적 웹사이트를 **Pre-Render**한 것을 CDN(Content Delivery Network)을 통해 웹 사이트를 제공해줍니다. 그렇기 때문에 기존 방식에 비해 **더 빠르게** 웹 사이트를 볼 수 있다는 거죠. \\r\\n\\r\\n#### 1. 기존 방식에 비해 더 빠르게 웹 사이트를 제공할 수 있습니다.\\r\\n구체적으로는 JAM Stack은 렌더링할 화면들을 모두 Pre-Render하여 제공되어 그만큼 사용자에게 화면을 보여주기 위해 준비하는 시간을 단축할 수 있습니다.\\r\\n\\r\\n이에 더불어서 브라우저에서 첫 응답을 받기까지 걸리는 시간인 TTFB(Time to First Byte)를 최소화하는 데에는 미리 빌드 된 파일을 CDN을 통해 제공하는 것보다 나은 방법이 없다고 합니다.\\r\\n\\r\\n#### 2. 안전한 웹 사이트를 제공할 수 있습니다.\\r\\n\\r\\nJAM Stack은 API를 통해 정적 사이트를 생성합니다.\\r\\n\\r\\n여기서 사용되는 API는 JAM Stack을 활용한 각 프레임워크에서의 **마이크로 서비스**로서, 사이트 생성을 위한 프로세스가 추상화되어 있기 때문에 그만큼 공격 노출 범위가 감소하게 됩니다.\\r\\n\\r\\n따라서 개발자는 웹 개발 중 발생할 수 있는 취약점에 대해 보다 덜 신경쓸 수 있습니다.\\r\\n\\r\\n#### 3. 스케일링하기 쉬운 웹 사이트를 제공할 수 있습니다.\\r\\n\\r\\n정적 웹사이트에서의 스케일링이란, 더 많은 지역에서 홈페이지를 제공할 수 있게 하는 의미입니다. 미리 빌드 된 파일 제공을 담당하는 CDN이 그 역할을 충분히 수행해낼 수 있습니다.\\r\\n\\r\\n\\r\\n### Gatsby VS Next.js\\r\\n\\r\\nGatsby와 함께 항상 언급되는 JAM Stack 기반 프레임워크인 Next.js와 비교를 또 빼놓을 수가 없죠. 둘 모두 React 기반의 프레임워크입니다.\\r\\n\\r\\n그럼 이쯤에서 한번쯤은 모두 고민을 할 것입니다. \\r\\n\\r\\n>🤷🏼‍♀️ Next.js가 대세라는데? 현재 1등을 달리고 있는 프레임워크라는데.. \\r\\n\\r\\n항상 프론트엔드 개발을 수행하면서 딜레마인 부분인것 같습니다. 트렌드를 쫓는다는것..하지만 각 프레임워크마다 모두 장단점이 있고, 목적에 맞게 잘 활용하는것이 중요하다고 생각합니다.\\r\\n\\r\\nGatsby와 Next.js 역시 두 프레임워크의 사용 용도가 다릅니다.\\r\\n\\r\\n`Next.js`는 정적 사이트 생성의 기능도 있지만 주로 **SSR**을 위해 사용하는 프레임워크입니다. 하지만 `Gatsby`는 **서버 없이**, 오로지 정적 사이트 생성를 위해 사용하는 프레임워크입니다.\\r\\n\\r\\n그래서 `Next.js`는 주로 기업단위의 대규모 프로젝트에 활용이 되고, `Gatsby`는 개인 포트폴리오나 기술 블로그 개발에 활용이 됩니다. (저는 저만의 기술 블로그를 만들 예정이기에 `Gatsby`를 활용할것입니다.)\\r\\n\\r\\n\",\"n\":0.05}}},{\"i\":9,\"$\":{\"0\":{\"v\":\"Promise 객체, async-await 함수를 활용한 비동기 처리\",\"n\":0.378},\"1\":{\"v\":\"## Promise 객체\\r\\n\\r\\n동기: 콜백 지옥에서 탈출하기\\r\\n\\r\\n**비동기 작업이 가질 수 있는 3가지 상태**\\r\\n\\r\\n![https://joshua1988.github.io/images/posts/web/javascript/promise.svg](https://joshua1988.github.io/images/posts/web/javascript/promise.svg)\\r\\n- Pending: 대기상태 (성공 or 실패)\\r\\n- Fulfilled: 성공 (Pending 상태에서 resolve 됐다)\\r\\n- Rejected: 실패 (Pending 상태에서 rejecet 됐다)\\r\\n\\r\\n\\r\\n#### Promise 객체를 활용한 비동기 구문\\r\\n```jsx\\r\\n// 기존 비동기 처리 \\r\\nfunction isPositive(number,resolve,reject) {\\r\\n\\tsetTimeout(()=> {\\r\\n\\t\\tif(typeof number === 'number') {\\r\\n\\t\\t\\t//resolve\\r\\n\\t\\t\\tresolve(number >=0 ? \\\"양수\\\" : \\\"음수\\\");\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treject(\\\"주어진 값이 숫자형이 아닙니다\\\");\\r\\n\\t\\t},2000);\\r\\n}\\r\\n\\r\\n// Promise 객체를 반환하여 구현한 비동기 코드\\r\\nfunction isPositiveP(number) {\\r\\n\\t//실행자 \\r\\n\\treturn new Promise(resolve,reject) => {\\r\\n\\t\\tsetTimeout(()=> {\\r\\n\\t\\t\\tif(typeof number === 'number') {\\r\\n\\t\\t\\t\\tresolve(number >=0 ? \\\"양수\\\" : \\\"음수\\\");\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treject(\\\"주어진 값이 숫자형이 아닙니다\\\");\\r\\n\\t\\t\\t},2000);\\r\\n\\t};\\r\\n}\\r\\n\\r\\nconst res = isPostiveP(101); //101\\r\\n\\r\\nres\\r\\n\\t.then((res) => { \\r\\n\\t\\tconsole.log(\\\"작업 성공: \\\",res);\\r\\n\\t}).catch((err)=>{\\r\\n\\t\\t\\tconsole.log(\\\"작업에러\\\")\\r\\n\\t}); \\r\\n```\\r\\n\\r\\n`then` 과 `catch` 구문을 활용하여 Fulfilled 상태인지 Rejected 상태인지 처리 결과값을 반환 받을 수 있습니다. \\r\\n\\r\\n\\r\\n\\r\\n## 여러 개의 프로미스 연결하기 (Promise Chaining)\\r\\n\\r\\n프로미스의 또 다른 특징은 **여러 개의 프로미스를 연결**하여 사용할 수 있다는 점입니다. 앞 예제에서 `then()` 메서드를 호출하고 나면 새로운 프로미스 객체가 반환됩니다. \\r\\n\\r\\n```jsx\\r\\nfunction getData() {\\r\\n  return new Promise({\\r\\n    // ...\\r\\n  });\\r\\n}\\r\\n\\r\\n// then() 으로 여러 개의 프로미스를 연결한 형식\\r\\ngetData()\\r\\n  .then(function(data) {\\r\\n    // ...\\r\\n  })\\r\\n  .then(function() {\\r\\n    // ...\\r\\n  })\\r\\n  .then(function() {\\r\\n    // ...\\r\\n  });\\r\\n```\\r\\n\\r\\n## async- await : 직관적인 비동기 처리 코드 작성\\r\\n```jsx\\r\\n// async 예제\\r\\nasync function helloAsync() {\\r\\n\\treturn 'hello async';\\r\\n} \\r\\n```\\r\\n\\r\\n`helloAsync()` 함수 콘솔을 찍으면 **Promise 객체**를 반환하는데 이는 `async` 함수의 특징 중, Promise 객체를 반환하는 특징 때문입니다.\\r\\n\\r\\n이때 다음 코드를 출력해보면 ‘hello async’가 정상적으로 콘솔에 출력됩니다. 이는 `res` 콜백함수가 `helloAsync`함수의 return을 바라봤다고 볼 수 있습니다. \\r\\n```jsx\\r\\nhelloAsync.then((res) => {\\r\\n\\tconsole.log(res);\\r\\n});\\r\\n```\\r\\n\\r\\n```jsx\\r\\n// await 예제\\r\\nfunction delay(ms) {\\r\\n\\treturn new Promise(resolve) => {\\r\\n\\t\\tsetTimeout((resolve,ms);\\r\\n\\t});\\r\\n}\\r\\n\\r\\nasync function helloAsync() {\\r\\n\\treturn delay(3000).then(()=> {\\r\\n\\t\\treturn 'hello async';\\r\\n\\t});\\r\\n} \\r\\n```\\r\\n\\r\\n위 함수를 **async-await 구문**으로 리팩토링하면 아래와 같습니다.\\r\\n```jsx\\r\\nasync function helloAsync() {\\r\\n\\tawait delay(3000);\\r\\n\\treturn 'hello async';\\r\\n} \\r\\n\\r\\nasync function main() {\\r\\n\\tconst res = await helloAsync();\\r\\n\\tconsole.log(res);\\r\\n} \\r\\nmain(); // 3초 기다렸다가 'hello async' 반환\\r\\n```\\r\\n\\r\\n이때 `await` 함수는 동기적으로 수행되기 때문에, await에 선언된 구문을 먼저 수행을 해야 return할 수 있는 구조이다. \\r\\n\\r\\n#### async-await 구문 정리\\r\\n```jsx\\r\\nasync function 함수명() {\\r\\n  await 비동기_처리_메서드_명();\\r\\n}\\r\\n```\\r\\n\\r\\n## API 호출\\r\\nAPI : 클라이언트와 서버간 통신할 수 있도록 도와줌 (request and response)\\r\\n\\r\\n\\r\\n\\r\\n```jsx\\r\\n// <JSON placeholder를 활용한 API 호출 메소드 예제>\\r\\nlet response = fetch('Json Placeholder URL...').then((res) => \\r\\n\\tconsole.log(res)\\r\\n);\\r\\n```\\r\\n\\r\\n이때 `fetch()` 함수에 hover시, `Promise<Response>` 로 Promise 객체를 반환함을 알 수 있습니다. 즉 `fetch()` 함수는 **비동기 함수** 임을 의미하고, `then` 키워드도 작성할 수 있습니다.\\r\\n\\r\\n이를 이제 async-await 함수를 통해 리팩토링 시, 다음과 같습니다.\\r\\n\\r\\n```jsx\\r\\nasync functiong getData() {\\r\\n\\tlet rawResponse = await fetch('Json URL');\\r\\n\\tlet jsonResponse = await rawResponse.json();\\r\\n\\tconsole.log(jsonResponse);\\r\\n}\\r\\ngetData(); // 객체 배열 반환 \\r\\n```\",\"n\":0.053}}},{\"i\":10,\"$\":{\"0\":{\"v\":\"chart.js 그래프 초기화 - destroy()\",\"n\":0.447},\"1\":{\"v\":\"## Issue - \\\"Canvas is already in use\\\"\\r\\n웹팩 번들링 문제를 해결하고 나니, 또 다른 이슈가 발생했었다. ~~산 넘어 산~~\\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/3ad00259-a0dc-4322-a127-1233bc165b1b/image.PNG)\\r\\n\\r\\n구글링 해보니, 꽤 유명한 에러 로그인것 같았다.\\r\\n\\r\\n초기에 그래프를 로딩하고 그리는데에는 문제가 없었지만, 다른 나라를 클릭하고 데이터를 불러올때, 기존 그래프가 **초기화** 되질 않아서 다음과 같이 이슈가 발생했다. 6일동안 삽질한 결과 다음과 같이 해결할 수 있었다.\\r\\n\\r\\n### 해결\\r\\n[chart.js 공식문서](https://www.chartjs.org/docs/latest/developers/api.html) 에서는 기존 차트 instance를 날리고 싶으면 `.destroy()` 메소드를 써보라고 합니다. \\r\\n\\r\\n>This must be called before the canvas is reused for a new chart.\\r\\n\\r\\n네 console에 잡혔던 에러랑 똑같은 말을 해주고 있죠,, 이걸로 쇼부를 봅시다.\\r\\n\\r\\n### 코드\\r\\n```tsx\\r\\nimport Chart from chart.js/auto\\r\\n\\r\\nfunction renderChart(data: number[], labels: string[]) {\\r\\n  const lineChart = $('#lineChart') as HTMLCanvasElement;\\r\\n  const ctx = lineChart.getContext('2d');\\r\\n  if (Chart.getChart(lineChart)) {\\r\\n    Chart.getChart(lineChart)?.destroy();\\r\\n  }\\r\\n\\r\\n  Chart.defaults.color = '#f5eaea';\\r\\n  Chart.defaults.font.family = 'Exo 2';\\r\\n  if (!ctx) {\\r\\n    return;\\r\\n  }\\r\\n  new Chart(ctx, {\\r\\n    type: 'line',\\r\\n    data: {\\r\\n      labels,\\r\\n      datasets: [\\r\\n        {\\r\\n          label: 'Confirmed for the last two weeks',\\r\\n          backgroundColor: '#feb72b',\\r\\n          borderColor: '#feb72b',\\r\\n          data,\\r\\n        },\\r\\n      ],\\r\\n    },\\r\\n    options: {\\r\\n      maintainAspectRatio: false, //차트 그래프 사이즈 고정\\r\\n    },\\r\\n  });\\r\\n}\\r\\n```\\r\\n해당 코드에서 3번째 line의 if문을 주목하시면,\\r\\n1. `Chart.getChart(lineChart)`가 만약 값이 할당되어 있다면 (=그래프가 그려져 있음)\\r\\n2. 그 차트값을 불러오고, `destroy()` (=그래프 초기화) \\r\\n\\r\\n를 의미합니다. 따라서 다음과 같이 코드를 수정 시, 그래프가 동적으로 변하지 않는 이슈가 해결됩니다. \\r\\n\\r\\n### +) 타입 강하게 잡아내기 : 옵셔널 체이닝(연산자 : ?)\\r\\n이때 `Chart.getChart(lineChart)?.destroy();` 이게 뭔가 싶으실텐데요\\r\\n해당 연산자는 **Optional Chaining** 이라고 다음 코드와 동일한 의미를 갖습니다.  \\r\\n\\r\\n```js\\r\\nif (Chart.getChart(lineChart) === null \\r\\n    || Chart.getChart(lineChart) === undefined) { \\r\\n  return; \\r\\n}\\r\\nelse { \\r\\n  Chart.getChart(lineChart).destroy(); \\r\\n}\\r\\n```\\r\\n`Chart.getChart(lineChart)` 가 `null` 또는 `undefined`에 해당하지 않는다면(=그래프가 이미 그려져 있는 상태) `destroy()` 하라는것과 동일한 의미를 지닙니다. \",\"n\":0.064}}},{\"i\":11,\"$\":{\"0\":{\"v\":\"Gatsby 블로그 - 검색기능 구현하기🔎\",\"n\":0.447},\"1\":{\"v\":\"## 동기\\r\\n동기라고 거창하게 써놨지만 별거 없습니다. 앞으로 이 블로그를 평생 쓸 예정인데.. 그럼 지금보다 포스팅 수도 더 많아질거고. 그러면 내가 일일이 무한 스크롤로 내려서 글을 찾는 행위 자체가 굉장히 불편한데? \\r\\n\\r\\n정말 이 사고의 흐름대로 생각했고 이 고민에 대한 결론은 \\\"그래. 검색 기능을 만들어보자!\\\" 로 귀결됐습니다. \\r\\n\\r\\n\\r\\n## 결과 화면\\r\\n![](https://velog.velcdn.com/images/damin1025/post/515c2fd7-c31e-4497-81c5-65f39ba31a30/image.gif)\\r\\n결과 화면은 위와 같이 검색 아이콘을 클릭 후 검색 페이지로 이동하여 keyword를 검색하면 아래에 관련 포스팅이 나열되고 그리고 원하는 포스팅으로 이동하는 방식으로 구현에 진행했습니다. \\r\\n\\r\\n\\r\\n## 어떤 기술을 선택할 것인가\\r\\n[공식 docs](https://www.gatsbyjs.com/docs/how-to/adding-common-features/adding-search/)를 보면 gatsby에 검색을 구현하는 방법을 크게 2가지로 소개하고 있습니다.\\r\\n\\r\\n첫 번째 방법은 **클라이언트 측 검색**입니다. 빌드 또는 런타임에 데이터를 인덱싱하고 이를 이용해 로컬에서 검색을 수행하는 방법입니다. 공식 docs에서는 `js-search`, `gatsby-plugin-elasticlunr-search`, `gatsby-plugin-local-search` 를 제시하고 있습니다.\\r\\n\\r\\n두 번째 방법은 **API기반 검색엔진**을 활용하는 방법으로 외부 서비스를 활용하는 방식입니다. 빌드 시점에 검색 대상 데이터들을 인덱싱해 외부 서비스에 올려두고 런타임에는 API로 검색합니다.\\r\\n\\r\\n하지만 API기반 검색엔진 사용 시 블로그의 빌드 배포 프로세스에 인덱스를 전송해야하고 사용 시 비용이 발생하거나 그리고 무료인 경우 횟수에 제약이 있어 굳이 사용해야 할 이유는 찾지 못했고, 클라이언트 측 검색 방법이 블로그에 부담이 덜 갈것 같은 방식이라고 생각하여 저는 첫번째 방법으로 아이디어를 scheme했습니다.\\r\\n\\r\\n## 검색 관련 라이브러리 \\r\\n여러 Gatsby Starter에 구현된 검색 기능을 참고해봤을때, GraphQL에서 요청한 edges를 모두 돌아 값을 불러오고, 그리고 그 값을 돌면서 search하는 방식으로 구현된 방식이 많았습니다. 하지만 search 시, 모든 배열의 사이즈에 depend하기 때문에 `O(N) time`이 소요되는 것을 생각하면 추후 포스팅 양이 많아지게 될때 검색 속도 저하를 야기할 수 있습니다. 따라서 검색 라이브러리를 활용하는 것이 시간 복잡도면에서 나을것 같다는 판단이 들었습니다. \\r\\n\\r\\n검색 라이브러리로 구현 시, 아래와 같은 기능을 제공합니다. \\r\\n\\r\\n- 인덱싱으로 빠른 검색\\r\\n- 검색하려는 콘텐츠(제목 혹은 본문)에 더 가중치를 둘 수 있다\\r\\n- 검색어 하이라이팅 기능\\r\\n- 검색에 and, or과 같은 논리 연산 적용 가능\\r\\n\\r\\n그럼 어떤 라이브러리로 이를 실현할 수 있을까 고민을 하던 중에 [해당 블로그](https://velog.io/@seyoung8239/Gatsby-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B2%80%EC%83%89%EA%B8%B0%EB%8A%A5-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0)에서 아이디어를 얻어갈 수 있었습니다.\\r\\n\\r\\n`flexsearch` 나 `lunr` 같은 경우는 한글 검색어 이슈가 있고(영문에 특화) `js-search`는 그 생태계가 아직 좁았기에 `fuse.js` 방식을 선택했습니다. \\r\\n\\r\\n## fuse.js 검색 \\r\\n[fuse.js](https://fusejs.io/)는 fuzzy하게 search한다에서 착안됐습니다. 여기서 fuzzy란 **대략적으로 검색**한다의 의미를 지니고 있습니다. \\r\\n\\r\\n가장 큰 장점은 백엔드의 지원이 필요 없고, 다른 라이브러리에 dependency를 갖고 있지 않으며 결정적으로 **클라이언트 측 검색**기반이라는 것이었습니다. \\r\\n\\r\\n### Gatsby에서 fuse.js 사용하기\\r\\nGatsby 빌드 과정에서 목록을 인덱싱하여 어딘가 저장해두어야 하고 이렇게 생성된 데이터는 블로그의 런타임에 fuse.js 인스턴스를 생성하여 사용하도록 구성해야 합니다.\\r\\n\\r\\n이때 빌드 과정은 플러그인을 활용하면 되고 런타임 검색은 hook을 활용하면 됩니다.\\r\\n\\r\\n### gatsby-plugin-fusejs\\r\\n[gatsby-plugin-fusejs](gatsby-plugin-fusejs) 해당 docs의 npm 명령어를 follow하여 설치를 진행 후, config를 설정합니다. \\r\\n\\r\\n```js\\r\\n// gatsby-config.js\\r\\n\\t{\\r\\n      resolve: `gatsby-plugin-fusejs`,\\r\\n      options: {\\r\\n        // 인덱스를 만들고자 하는 데이터의 쿼리\\r\\n        query: `\\r\\n          {\\r\\n            allMarkdownRemark {\\r\\n              nodes {\\r\\n                id\\r\\n                rawMarkdownBody\\r\\n                fields {\\r\\n                  slug\\r\\n                }\\r\\n                frontmatter {\\r\\n                  title\\r\\n                }\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n        `,\\r\\n        // 인덱스를 만들고자 하는 데이터의 프로퍼티\\r\\n        keys: ['title', 'body'],\\r\\n        // graphql의 결과물을 단순 객체 배열로 변환하는 함수\\r\\n        normalizer: ({ data }) =>\\r\\n          data.allMarkdownRemark.nodes.map((node) => ({\\r\\n            id: node.id,\\r\\n            path: node.fields.slug,\\r\\n            title: node.frontmatter.title,\\r\\n            body: node.rawMarkdownBody,\\r\\n          })),\\r\\n      },\\r\\n    },\\r\\n```\\r\\n설치 후 gatsby-config.js에 인덱스로 만들어지기 원하는 데이터의 쿼리, 데이터 중에서도 검색이 되었으면 하는 프로퍼티, GraphQL 결과물을 객체 배열로 변환하기 위한 함수를 옵션으로 전달합니다. \\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/4ad55151-b71b-474f-bb50-aea87c69e6d3/image.PNG)\\r\\n\\r\\nGraphQL 사이트에 접속 시, `allFusejs` 필드가 추가 됨을 확인할 수 있습니다.\\r\\n\\r\\n### react-use-fusejs\\r\\n다음으론 만들어진 인덱스를 활용하기 위해 런타임에 hook을 활용하여 검색을 수행해야 합니다. \\r\\n\\r\\n이때 매번 검색어를 입력 시, 인덱스를 parsing 후 인스턴스를 생성하게 되면 추후 포스팅의 양이 많아질때 자원이 낭비됩니다. (Props Drilling) \\r\\n따라서 이를 방지하기 위해서 index 페이지를 처음 Search 페이지를 클릭 했을때 모두 다운받고 그리고 그 다운받은 data들을 context에 담아 재사용할 수 있도록 유도하는 것이 더 효율적일것입니다. \\r\\n\\r\\n```tsx\\r\\n/* Search.tsx */\\r\\n\\r\\n  // index.js(최상위)로부터 다운 후 파싱하여 검색을 수행\\r\\n  const data = useStaticQuery<SearchProps>(graphql`\\r\\n    {\\r\\n      fusejs {\\r\\n        publicUrl\\r\\n      }\\r\\n    }\\r\\n  `)\\r\\n\\r\\n  /**\\r\\n   * 1. Get User Search Input value\\r\\n   * 2. Collect all Index data and store in context\\r\\n   * 3. Based on fuseData find query data with fuzzy search\\r\\n   * 4. Lazy Loading (when Post's amount is getting larger)\\r\\n   */\\r\\n  const [query, setQuery] = useState<string>('')\\r\\n  const { fuseData, setFuseData } = useContext(AppContext)\\r\\n  const result = useGatsbyPluginFusejs<SearchItem>(query, fuseData)\\r\\n  const [isFetching, setIsFetching] = useState(false)\\r\\n\\r\\n  const fetching = useRef(false)\\r\\n  useEffect(() => {\\r\\n    if (!fetching.current && !fuseData && query) {\\r\\n      fetching.current = true\\r\\n\\r\\n      fetch(data.fusejs.publicUrl)\\r\\n        .then(res => res.json())\\r\\n        .then(data => setFuseData(data))\\r\\n        .finally(() => setIsFetching(false))\\r\\n    }\\r\\n  }, [fuseData, query, setFuseData])\\r\\n```\\r\\n\\r\\n인덱스를 재사용하기 위해서 context에 담을 것이고, 이는 최상위 컴포넌트에서 구현해줘야 합니다. 따라서 `context` 폴더를 새로 생성하고, `app.tsx` 파일을 새로 만들어서 아래와 같이 context를 App ➡ Search로 data를 위임할 수 있도록 합니다. \\r\\n\\r\\n```tsx\\r\\n/* app.tsx */\\r\\n\\r\\nimport React, {\\r\\n  createContext,\\r\\n  SetStateAction,\\r\\n  useState,\\r\\n  ReactNode,\\r\\n  FunctionComponent,\\r\\n} from 'react'\\r\\nimport { Dispatch } from 'react'\\r\\n\\r\\ninterface AppContext {\\r\\n  fuseData: any\\r\\n  setFuseData: Dispatch<SetStateAction<any>>\\r\\n}\\r\\n\\r\\nexport const AppContext = createContext<AppContext>({\\r\\n  fuseData: null,\\r\\n  setFuseData: () => {},\\r\\n})\\r\\n\\r\\ntype AppProps = {\\r\\n  children: ReactNode\\r\\n}\\r\\n\\r\\n// Provide Props to Search\\r\\nconst AppProvider: FunctionComponent<AppProps> = function ({ children }) {\\r\\n  const [fuseData, setFuseData] = useState(null)\\r\\n\\r\\n  return (\\r\\n    <AppContext.Provider value={{ fuseData, setFuseData }}>\\r\\n      {children}\\r\\n    </AppContext.Provider>\\r\\n  )\\r\\n}\\r\\n\\r\\nexport default AppProvider\\r\\n```\\r\\n이때 Provider에 value를 담을때 객체로 한번 더 감싸서 보내주는 이유는 data의(state) 값이 변경될때 setFuseData는 재생성되지 않지만, fuseData가 재생성되지 않도록 하기 위해 감싸서 보냅니다. \\r\\n\\r\\n```js\\r\\n// gatsby-browser.js\\r\\nimport { AppProvider } from './src/context/app'\\r\\n \\r\\nexport const wrapRootElement = ({ element }) => {\\r\\n  return <AppProvider>{element}</AppProvider>\\r\\n}\\r\\n```\\r\\n\\r\\n위와 같이 코드를 모두 구성 시, React-Developer-Tools를 확인하면 Context에 post 정보들이 담겨있는것을 확인할 수 있습니다. 그렇기 때문에 검색어를 입력 시, 해당 값들은 이미 담겨있어 자원의 낭비를 최소화 할 수 있습니다. \\r\\n![](https://velog.velcdn.com/images/damin1025/post/3258df66-245c-4b99-84aa-6f0d09f7371e/image.PNG)\\r\\n\\r\\n\\r\\n## 배포 후 성능 check\\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/56f43f3a-a80b-42e2-8091-35326e624444/image.PNG)\\r\\n\\r\\n검색 기능 추가 후, lightHouse 점수를 확인해본 결과 퍼포에서 1점 깎인것 빼곤 모두 100을 유지했다..!! \\r\\n\",\"n\":0.035}}},{\"i\":12,\"$\":{\"0\":{\"v\":\"Gatsby 블로그 - 이전글/다음글 버튼 로직 구현하기 \",\"n\":0.378},\"1\":{\"v\":\"## 동기 \\r\\n요즘 `Gatsby`를 활용하여 Tech Blog를 구현하고 있습니다. 얼추 포스팅 템플릿도 구현이 된 상태에서, 다른 사람들이 만든 블로그와 특히 개발 블로그로 유명한 **velog**에서 어떤 요소들을 갖고 있는지 체크해본 결과, \\r\\n\\r\\n- TOC (Table Of Contents) 기능 \\r\\n- 이전글/다음글 기능 \\r\\n- 댓글 기능 \\r\\n- ScrollToTop 버튼 기능 \\r\\n\\r\\n이 정도로 추려 볼 수 있을것 같습니다. 그래서 저도 최소한 저 기능들은 탑재한 블로그를 제작해야지 생각했습니다. 댓글 기능(Utterance 활용)이나 ScrollToTop 기능은 구글링하면 코드 예제도 많아서 금방 구현할 수 있었습니다. \\r\\n\\r\\n제가 이 블로그를 쓰는 이유는 **이전글/다음글** 기능 제작기를 해당 포스팅을 통해서 나열하고자 합니다.. (왜냐하면 3일동안 삽질했기에)\\r\\n그리고 결정적인 동기는 단순히 사람들이 이 기능을 많이 개발해서 나도 해야지 보단 제 블로그의 작동 구조에 대해서 생각했습니다.\\r\\n\\r\\n>👀 시나리오 \\r\\n>1. 블로그를 읽는다.\\r\\n>2. 이전글이나 다음글을 보고 싶은데?\\r\\n>3. ScrollToTop 버튼을 누르고 `<-` 버튼을 눌러 홈화면으로 돌아온다\\r\\n\\r\\n사용자 경험이 떨어질것 같은 시나리오라고 생각했습니다. 따라서 **이전글/다음글** 기능을 구현해서 사용자가 다른 포스팅도 쉽게 접근할 수 있도록 해야겠다! 라는 생각에서 시작했습니다. \\r\\n\\r\\n## 결과\\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/577bc8c0-a684-4373-9bb8-700597f2a817/image.gif)\\r\\n\\r\\n우선 결과부터 보여드리겠습니다. 동작 방식은 위와 같고, 만약 가장 최신 포스트이거나 아니면 가장 오래된 포스트라면 다음글/이전글 버튼이 비활성화 될 수 있도록 로직을 설계했습니다. \\r\\n\\r\\n## gatsby-node.js 파일 수정 \\r\\n\\r\\n마크다운 파일을 페이지로 변환해주는 `createPages` 에서 비동기적으로 query를 요청하는 부분입니다. 해당 부분에서는, `contents` 폴더 (이 부분은 `gatsby-config.js`에서 options을 설정해줬을거라고 생각하고 설명은 생략하겠습니다.) 에 담긴 마크다운 파일들을 모두 요청합니다. \\r\\n\\r\\n```jsx\\r\\nexports.createPages = async ({ actions, graphql, reporter }) => {\\r\\n  const { createPage } = actions;\\r\\n\\r\\n  // Get All Markdown File For create Pages\\r\\n  const queryAllMarkdownData = await graphql(\\r\\n    `\\r\\n      {\\r\\n        allMarkdownRemark(\\r\\n          sort: {\\r\\n            order: DESC\\r\\n            fields: [frontmatter___date, frontmatter___title]\\r\\n          }\\r\\n        ) {\\r\\n          edges {\\r\\n            node {\\r\\n              fields {\\r\\n                slug\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    `,\\r\\n  );\\r\\n  // ...\\r\\n}\\r\\n```\\r\\n반드시 `graphiql` 에서 해당 쿼리가 정상적으로 출력되는지 확인합니다. (slug가 알맞게 나오는지가 중요) \\r\\n\\r\\n\\r\\n```jsx\\r\\n  // Import Post Template Component\\r\\n  const PostTemplateComponent = path.resolve(\\r\\n    __dirname,\\r\\n    'src/templates/post_template.tsx',\\r\\n  );\\r\\n\\r\\n  const posts = queryAllMarkdownData.data.allMarkdownRemark.edges\\r\\n  posts.forEach((\\r\\n    {\\r\\n      node: {\\r\\n        fields: { slug },\\r\\n      }\\r\\n    },\\r\\n    index\\r\\n  ) => {\\r\\n    // Logic of Prev/Next Button \\r\\n    const prev = index === 0 ? null : posts[index-1]\\r\\n    const next = index === posts.length -1 ? null: posts[index+1]\\r\\n    createPage({\\r\\n      path: slug,\\r\\n      component: PostTemplateComponent,\\r\\n      context: {\\r\\n        slug,\\r\\n        prev,\\r\\n        next,\\r\\n      }\\r\\n    })\\r\\n  })\\r\\n```\\r\\n`posts` 배열을 돌면서, 아까 위에서 언급한 로직을 `prev`, `next`에 작성합니다. 만약 가장 최신글이거나, 가장 오래된 글이면 slug는 <span style=\\\"color:red\\\">null</span>로 세팅될것입니다. 그리고  `createPage`에 context에 `prev`, `next`를 추가합니다. \\r\\n\\r\\n\\r\\n## 이전글/다음글 컴포넌트 설계하기 \\r\\n이제 이전글/다음글 버튼 컴포넌트를 만듭시다. 뭐 디자인적인 부분은 본인이 원하는대로 Styling에 진행하면 될 것 같습니다. \\r\\n\\r\\n공통적인 부분이라면, `Props`를 부모 컴포넌트(`post_template`-블로그 포스팅 템플릿)에서 받아오는 부분일것 같습니다. 우리는 slug를 활용해서 접근할 것이고, slug는 string 타입입니다. 따라서 Props로는 `이전글 slug`와 `다음글 slug`를 받아오면 될 것 같습니다. \\r\\n\\r\\n```tsx\\r\\nexport type PrevNextProps = {\\r\\n  previousPagePath: string | null\\r\\n  nextPagePath: string | null\\r\\n}\\r\\n\\r\\nconst PostPrevNextBtn: FunctionComponent<PrevNextProps> = function ({\\r\\n  previousPagePath,\\r\\n  nextPagePath,\\r\\n}) {\\r\\n  return (\\r\\n    <StyledPager>\\r\\n      <ul>\\r\\n        <li>\\r\\n          {previousPagePath !== null ? (\\r\\n            <Link to={previousPagePath}>\\r\\n              <Left /> 다음글\\r\\n            </Link>\\r\\n          ) : (\\r\\n            <span>\\r\\n              <Left /> 다음글\\r\\n            </span>\\r\\n          )}\\r\\n        </li>\\r\\n\\r\\n        <li>\\r\\n          {nextPagePath !== null ? (\\r\\n            <Link to={nextPagePath}>\\r\\n              이전글 <Right />\\r\\n            </Link>\\r\\n          ) : (\\r\\n            <span>\\r\\n              이전글 <Right />\\r\\n            </span>\\r\\n          )}\\r\\n        </li>\\r\\n      </ul>\\r\\n    </StyledPager>\\r\\n  )\\r\\n}\\r\\n\\r\\nexport default PostPrevNextBtn\\r\\n```\\r\\n\\r\\n## post_template 에서 slug 조작하기 \\r\\npost_template은 엄밀히 따지면 위에서 설계한 컴포넌트에 Props를 뿌려줘야할 부모 컴포넌트에 해당합니다. 우리는 해당 템플릿에서 `gatsby-node.js` 에서 query로 요청한 값들을 이제 받아와야 합니다. 우선 Props로 그 부분에 대한 타입을 명시합니다. \\r\\n\\r\\n```tsx\\r\\ntype PostTemplateProps = {\\r\\n  // ...\\r\\n  pageContext: {\\r\\n    prev: {\\r\\n      node: {\\r\\n        fields: {\\r\\n          slug: string\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    next: {\\r\\n      node: {\\r\\n        fields: {\\r\\n          slug: string\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n그리고 pageContext가 잘 받아와지는지 `console.log(pageContext)`를 수행해보세요. `next,prev,slug`가 object형태로 출력이 된다면 정상적으로 query요청값을 받아왔습니다. \\r\\n\\r\\n```tsx\\r\\nconst PostTemplate: FunctionComponent<PostTemplateProps> = function ({\\r\\n  //...\\r\\n  pageContext: { prev, next },\\r\\n}) {\\r\\n  return (\\r\\n    //...\\r\\n      <PostPrevNextBtn\\r\\n        previousPagePath={prev ? prev.node.fields.slug : null}\\r\\n        nextPagePath={next ? next.node.fields.slug : null}\\r\\n      />\\r\\n    //...\\r\\n  )\\r\\n}\\r\\n```\\r\\n잘 받아온 `next`와 `prev`의 object값을 parsing한 slug값을, `PostPrevNextBtn` 컴포넌트에 Props로 넘겨줍니다. \\r\\n\\r\\n이때 가장 최신글이나,가장 오래된 글에 대해서는 pageContext console을 찍어보면 `prev,next` object이 **key값으로도 등장하지 않습니다.** 이에 대한 validation check가 필요하기 때문에 위와 같이 삼항연산자를 통해 걸러줍니다. \\r\\n\\r\\n\\r\\n## 맺음말\\r\\n잘 작동하나요? 저도 여러번의 삽질을 통해서 구현한거라 모두에게 상용될 방법은 아니라고 생각합니다 ㅎㅎ.. 제가 구현한 로직도 역시 참고용으로 본인 코드에 필요한 부분만 떼어가서 살을 붙히시면 될 것 같습니다.🤗 \\r\\n\",\"n\":0.039}}},{\"i\":13,\"$\":{\"0\":{\"v\":\"Gatsby 블로그 - TOC 기능 구현하기\",\"n\":0.408},\"1\":{\"v\":\"\\r\\n🤠 글이 꽤 깁니다! \\r\\n## 💭 동기 \\r\\n\\r\\n포스팅을 읽다 보면, 다시 읽고 싶은 부분으로 돌아가고 싶었던 경험이 있을 겁니다. 이때 일일이 스크롤 해서 내가 원하는 콘텐츠를 읽는 것은 사용자 경험이 굉장히 떨어지는 행위입니다.\\r\\n\\r\\n따라서 많은 개발 블로그에는 **TOC**, 즉 Table Of Contents를 제공합니다. 저 역시 제 블로그에 방문해 주시는 유저분들께 편리함을 제공하고자 TOC 기능을 제작하고 구현에 진행했습니다.\\r\\n\\r\\nVelog나 다른 개발 블로그들에서 봤을 땐 복잡할 거라고 생각은 안 했는데, 역시 만만한 건 아무것도 없었습니다😅 \\r\\n\\r\\n## 결과 \\r\\n\\r\\n먼저 구현 결과부터 보여드리겠습니다. \\r\\n\\r\\n스크롤 시, 일정 위치에 heading이 scope 시 오른쪽에 있는 TOC의 각각의 요소들에 active 값이 활성화됨을 볼 수 있습니다.\\r\\n![](https://velog.velcdn.com/images/damin1025/post/021cd97b-05b8-470c-8d95-1c82fe32e9e7/image.gif)\\r\\n\\r\\n그리고 각 콘텐츠를 클릭 시, 알맞는 heading으로 direct 하게 이동합니다.\\r\\n![](https://velog.velcdn.com/images/damin1025/post/ed65ab46-8384-4b63-8db1-f060334ae8a5/image.gif)\\r\\n\\r\\n그럼 제가 어떤 flow로 TOC 기능을 개발했는지 회고하고자 합니다. \\r\\n\\r\\n## header를 어떻게 갖고 올것인가?\\r\\n우선 TOC 기능을 구현하는 데 있어, 가장 중요한 것은 포스팅에 있는 header를 어떻게 갖고 올 것인가입니다. 당연하게도 `gatsby-node.js`에서 GraphQL로 요청해야 하는데, 이때 어떤 필드를 참조할 것인가를 생각해 봐야 합니다.\\r\\n\\r\\n1) `tableOfContents` 필드를 활용하기\\r\\n`tableOfContents` 필드를 GraphQL로 요청하여 `dangerouslySetInnerHTML`에 __html 요소로 Props를 보내서 렌더링 하는 방법이 있습니다.\\r\\n![](https://velog.velcdn.com/images/damin1025/post/dde204d0-a5ed-41f9-808e-dc0ab46cfef6/image.PNG)\\r\\n\\r\\n\\r\\n2) `headings` 필드의 depth와 value를 활용하기 \\r\\n![](https://velog.velcdn.com/images/damin1025/post/eacbf940-6312-4203-8750-93f29f440712/image.PNG)\\r\\n\\r\\n여기서 depth는 h1, h2,...에서 숫자에 해당하는 부분이고, value는 제목입니다. 저는 직접 depth를 handle 하여 CSS도 Styling 할 것이고, 그리고 배열을 돌면서 value를 TOC 컴포넌트에 렌더링 하고 싶었기 때문에 1번보단 2번 방법을 택했습니다. \\r\\n\\r\\n## Value를 어떻게 slug화 할것인가?\\r\\n보통 `tableOfContents` 필드를 활용해서 구현한다면 slug를 자체적으로 알아서 만들어서 `href`로 접근할 수 있도록 값이 부여되는데, 저같은 경우는 `headings`를 활용하기 때문에 **제목을 어떻게 slug 화할 것인가**를 고민해 봤어야 했습니다.\\r\\n\\r\\n정말 npm은 없는게 없군요.. [github-slugger](https://www.npmjs.com/package/github-slugger) 라는 패키지를 통해서 slug에 대한 고민을 해결할 수 있었습니다. 해당 패키지를 npm으로 설치하고, `slug(value)` 메서드만 선언하면 알아서 value(제목)를 slug화 해주는 아주 친절한 패키지를 활용하여 해당 고민을 해결할 수 있었습니다.  \\r\\n\\r\\n## Data 흐름은? \\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/6f0fe709-8358-4507-aba0-ca1bc62cb64a/image.PNG)\\r\\n\\r\\n데이터 흐름은 위와 같이 `post_template.tsx` (포스팅 템플릿)에서 GraphQL로 요청한 headings(depth,value)를 `PostTOC.tsx` 에 전달하는 구조로 설계하고 구현에 진행했습니다. \\r\\n\\r\\n## TOC 컴포넌트 Styling \\r\\n\\r\\n자 그럼 GraphQL로 요청한 headings들을 이쁘게 Render하기 위해  Styling 작업을 해야 합니다. \\r\\n\\r\\n사실 TOC 기능을 만들면서 꽤 시간을 많이 들였던 부분이 바로 이 Styling 부분이기도 했습니다. CSS적으로 deep하게 MockUp 했고.. 따라서 이건 본인이 스스로 고민하면서 만드는 것을 추천드립니다. 제 코드를 봐도 본인 프로젝트에서는 또 적용이 안될수도 있기 때문입니다 ㅠ  \\r\\n\\r\\n이건 제가 Scheme한 부분입니다. \\r\\n![](https://velog.velcdn.com/images/damin1025/post/dd2ad444-f17c-4215-9d85-52ff52623c6d/image.jpg)\\r\\n이런식으로 본인이 스스로 한번 구상하시는 것을 추천드립니다 🐣 그리고 포스팅을 읽을때, TOC 컴포넌트가 **일정 위치에 고정**되도록 구현하고 싶었기 때문에 `Sticky` 속성을 부여했습니다. \\r\\n\\r\\n또한 다크모드로 전환 시, 콘텐츠들의 글자색들이 바뀌어야 하기 때문에 body의 classList가 'dark'면 바뀔 수 있도록 값을 부여했습니다. \\r\\n\\r\\n```css\\r\\na {\\r\\n\\tcolor: ${\\r\\n    isBrowser() && window.document.body.classList.contains('dark')\\r\\n\\t};\\r\\n    text-decoration: none;\\r\\n}\\r\\n```\\r\\n\\r\\n## Scroll시 각 header에 맞게 Active 기능 부여하기\\r\\n\\r\\nScroll시 각 Header에 맞게 Active하는 기능을 어떻게 구현해야 하는지를 고민해봤을때, 저는 Scroll값과 offsetTop값을 활용하여 처리하는 것으로 구상했습니다. \\r\\n\\r\\n`InterSectionObserver` API를 활용하는 것이 물론 퍼포먼스적으로 좋다는 지표도 있지만, 우선 아직 저의 무지함으로 인해.. 구상부터 잘 이루어지지 않았습니다🙁.. Learning Curve가 있기에 좀 더 익숙해지면 해당 방법으로 마이그레이션을 고려할 수 있을것 같습니다.  \\r\\n\\r\\n따라서 제가 생각한 방법은 Scroll값에 따라 headings 배열을 돌면서 일정 offsetTop 값에 도달하면 Index 값을 참조하여 active 할 수 있는 방법은 어떨까? 로 구상했고 이 방법으로 구현에 진행할 수 있었습니다. \\r\\n\\r\\n```tsx\\r\\n// PostTOC.tsx\\r\\nconst calcActive = useCallback(() => {\\r\\n    if (!isBrowser) {\\r\\n      return 0\\r\\n    }\\r\\n    const offsets: number[] = []\\r\\n\\r\\n    // bring each headings offsetTop\\r\\n    for (const { slug } of headers) {\\r\\n      const element = document.getElementById(slug)\\r\\n      if (!element) {\\r\\n        return\\r\\n      }\\r\\n      offsets.push(element.offsetTop - 10)\\r\\n    }\\r\\n\\r\\n    const maxIndex = offsets.length - 1\\r\\n    const { scrollY } = window\\r\\n    let index = 0\\r\\n\\r\\n    // Scroll Active Trigger (looping the offset)\\r\\n    if (scrollY === 0 || scrollY <= offsets[0]) {\\r\\n      index = 0\\r\\n    } else if (\\r\\n      window.innerHeight + scrollY >= document.body.scrollHeight ||\\r\\n      scrollY >= offsets[maxIndex]\\r\\n    ) {\\r\\n      index = maxIndex\\r\\n    } else {\\r\\n      index = findIndex(offsets, offset => offset >= scrollY) - 1\\r\\n    }\\r\\n    return index\\r\\n  }, [headers])\\r\\n```\\r\\n\\r\\n`headers` 배열을 참조하여 value를 slug화 한 각각의 태그를 `element`로 불러오고, 각각의 offsetTop 값을 `offsets` 배열에 담습니다. 다시 말하면 `offsets` 배열은 document 기준의 각 header들의 위치를 의미합니다. \\r\\n\\r\\n그리고 스크롤 할때마다 Y축의 값을 반환하는 `scrollY` 를 통해서, 3가지 상황으로 조건문을 분기할 수 있습니다. (사실 글보단 코드가 더 이해가 잘 될것 같긴 합니다😅)\\r\\n\\r\\n1. 만약 `scrollY` 값이 0(맨위) 또는 `offsets[0]`(가장 첫번째 header 문구) 보다 작거나(닿기직전) 해당 위치에 도달 했다면? : **index = 0으로 부여** \\r\\n\\r\\n2. `scrollY` 값이 `offset[maxIndex]`보다 크거나 같을때(마지막 header문구 위치와 같거나 지나쳤을때) 또는 window의 innerHeight와 `scrollY` 를 합친 값이 document 기준의 scrollHeight보다 크거나 같을때(마지막 header문구를 지나친건 아니지만, ScrollHeight(스크롤하지 않았을때 전체 높이)를 넘겼을때) : **index = maxIndex로 부여** \\r\\n\\r\\n3. 1,2에 해당하지 않을때 \\r\\n\\r\\n그래서 이 `index`를 활용해서 event를 trigger합니다. \\r\\n```tsx\\r\\n// PostTOC.tsx\\r\\nconst [currentIndex, setCurrentIndex] = useState<number | undefined>(0)\\r\\n\\r\\n  useEffect(() => {\\r\\n    setCurrentIndex(calcActive())\\r\\n    const onScrollForActive = throttle(() => setCurrentIndex(calcActive()), 300)\\r\\n    window.addEventListener('scroll', onScrollForActive)\\r\\n\\r\\n    return () => {\\r\\n      onScrollForActive.cancel()\\r\\n      window.removeEventListener('scroll', onScrollForActive)\\r\\n    }\\r\\n  }, [calcActive])\\r\\n```\\r\\n`useEffect()` Hook을 활용하여 `calcActive`에 따라 event가 Trigger될 수 있도록 dependency Array에 할당합니다. \\r\\n\\r\\n이때 Scroll시, 매번 offsetTop 값과 ScrollY값을 연산해야 하기 때문에 싱글 스레드에 조금이라도 최적화 하는 작업이 필요합니다. 왜냐하면 Scroll시, 매번 연산하기 때문에 console을 찍어보면 값들이 무수히 찍히기 때문입니다.\\r\\n\\r\\n따라서 저는 [lodash-es](https://www.npmjs.com/package/@types/lodash-es)에서 제공하는 `throttle()` 메소드를 활용하여 Scroll Event를 최적화 했습니다. 이는 Scroll시 매번 요청되는 call을 `SetTimeOut()` 연산과 같은 구조로, 300ms를 기다렸다가 `onScrollForActive`를 요청합니다. \\r\\n\\r\\n```tsx\\r\\n// PostTOC.tsx\\r\\n<ol>\\r\\n{headers.map(({ value, depth }, idx) => (\\r\\n\\t<li\\r\\n    key={idx}\\r\\n    style={{ paddingLeft: `${depth * 11}px` }}\\r\\n    className={currentIndex === idx ? 'active' : ''}\\r\\n    >\\r\\n\\t\\t// ...\\r\\n\\t</li>\\r\\n    ))}\\r\\n</ol>\\r\\n```\\r\\n`calcActive()` 함수의 리턴 index가 `useState` Hook의 현재 state로 담기는 `currentIndex`에 담기면서, 실제 ol 태그내에서 headers 배열(`PostTOC` 컴포넌트 상단에서 `useMemo()`를 통해 연산한 값을 재사용 했습니다.) 을 도는 idx 값과 비교하게 되면서 `currentIndex`와 일치하는 idx에 대해서만 active 활성화를 부여하게 되면, Scroll시 bold체로 활성화 되는 것을 볼 수 있습니다. \\r\\n\\r\\n(*`li`태그 에서 style은 indentation을 주기 위해서 depth를 활용한 것입니다.)\\r\\n\\r\\n## header에 맞는 href로 이동하기 \\r\\n그리고 `a` 태그에 href 값으로 `slug(value)`를 할당하게 되면 헤더에 맞는 위치로 이동하게 됩니다. \\r\\n\\r\\n```tsx\\r\\n// PostTOC.tsx\\r\\n//...\\r\\n<a data-idx={idx} href={`#${slug(value)}`}>\\r\\n\\t{value}\\r\\n</a>\\r\\n//...\\r\\n```\\r\\n\\r\\n### 🪓 Issue Handle  \\r\\n![2023-05-16 11;09;11](https://github.com/dobyming/dobyming.github.io/assets/90133704/d9c2b8db-6934-4e50-9e93-bc0d5eb196f3)\\r\\n\\r\\nTesting을 하던 중, console에 이런 error log가 찍혔습니다. 공통점을 보니, 숫자로 시작하는 헤더를 `querySelector`가 parsing을 수행할 수 없다는 류의 에러였습니다. (TOC 컨테이너에 해당하는 헤더값을 클릭 시, 해당하는 헤더로 이동하지도 않았습니다.) \\r\\n\\r\\n```tsx\\r\\nconst heading = document.querySelector<HTMLHeadingElement>(href)\\r\\nif (!heading) {\\r\\n\\treturn\\r\\n}\\r\\n\\r\\nwindow.scrollTo({\\r\\n\\ttop: heading.offsetTop,\\r\\n  behavior: 'smooth',\\r\\n })\\r\\n```\\r\\n\\r\\n문제가 발생한 코드였고 [StackOverflow](https://stackoverflow.com/questions/37270787/uncaught-syntaxerror-failed-to-execute-queryselector-on-document)에서 보니, `querySelctor`는 숫자로 시작하는 heading은 인식하지 못한다는 것이었습니다. 따라서 위의 코드는 과감히 제거하고, `a` 태그의 `href`에 slug화 한 value를 할당하여 숫자로 시작하는 slug도 인식할 수 있도록 트러블 슈팅을 진행했습니다. \\r\\n\\r\\n## 🔮 후기 \\r\\n일주일 가까이? 시간을 쏟고 나름 고생하면서 만들었네요.. 기능 개발에서 많은 고민과 시간을 투자해서 그런지 더 소중하게 다가옵니다. 의외로 CSS 스타일링도 내가 아는게 다 아니었구나를 또 깨달으며 역시 계속 배워야 한다는 것을 깨달았던 feature 개발이었습니다. \\r\\n\\r\\n성능상 최적화해야 할 부분이 남은 숙제겠네요! 그래도 스스로 TOC 기능을 만든건 꽤나 뿌듯합니다.😊\",\"n\":0.031}}},{\"i\":14,\"$\":{\"0\":{\"v\":\"Gatsby 블로그 - 개발하면서 만났던 Issue\",\"n\":0.408},\"1\":{\"v\":\"`Gastby` 프레임워크를 활용하여 블로그를 구현하고 운영한지 어느덧 2달이 다 되가고 있네요.. 다양한 기능들을 블로그에 하나씩 덧붙혀가면서 동시에 에러도 같이 늘어났었는데요 😅 \\r\\n\\r\\n이 기간동안 제가 접한 Issue들과 어떻게 해결하려고 노력했는지를 여러분께 공유하려고 해요. \\r\\n\\r\\n\\r\\n## #418 #423 Minified Error \\r\\n어느정도 블로그를 구현하고 배포하면서 lightHouse로 Performance 점수를 측정하는데 Best Practices 부문에서 자꾸 92점이라는 Score가 찍혀있었고, 해당 원인으로는 Console log에 에러가 찍히는데? 라고 알려주더라구요. \\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/f8871c18-0dc4-4b03-be52-0fcf92b7ab65/image.PNG)\\r\\n\\r\\nLightHouse에서 말한 이슈가 이걸 의미하는걸까 싶었고 또한 콘솔에 많은 에러가 찍혀있는건 개발자 입장에서도 매우 거슬렸기 때문에 이를 본격적으로 해결하고자 했어요.\\r\\n\\r\\n[해당 블로그](https://vaihe.com/blog/react-hydration-error-explained/)에서 그 원인을 찾을 수 있었어요. 이 에러의 정확한 명칭은 **React Hydration** 에러이고, 이 에러는 Client Render와 Server Render가 일치하지 않을때 발생한다고 해요. \\r\\n\\r\\nGatsby는 Pre-Render되는 속성이 있기 때문에, 이때 이 Pre-Render되는 HTML 파일과 React(대표적 CSR 라이브러리이자 Gatsby의 근간)에서 Virtual Dom으로 쌓아올린 HTML 파일과 <span style=\\\"color:red\\\">일치하지 않아서 발생하는 거예요.</span> 그래서 Pre-Render된 HTML 파일이 렌더링이 되는 것이 아니라 자체적으로  React가 쌓아올린걸로 replace 되버리는 거죠. \\r\\n\\r\\n이렇게 되버리면 우리는 Gatsby의 장점을 살릴 수 없어요 😱\\r\\n\\r\\n### 해결\\r\\n결국엔 모든 문제는 Server와의 연산이 요구되는 코드에서 에러가 발생하는거라고 판단했어요. Pre-Render 시에는 Server 연산을 참조하지 못하는데요, 대표적으로 `window` 객체라는게 뭔지도 모르는 상태에서 요청하면 안되기 때문에 이를 Validation하는 작업이 필요해요.\\r\\n\\r\\n제 블로그에서 첫 index page를 load 할때 가장 의심이 가는 부분은 바로 다크모드를 handle할 수 있는 `HeaderTheme` 컴포넌트였어요. 왜냐하면 localStorage를 참조하여 dark인지 light인지를 담는 연산을 수행하고 있기 때문이에요. \\r\\n\\r\\n그래서 `HeaderTheme`의 토글 버튼이 로딩을 **lazy loading**으로 수행함으로써 이 문제를 해결할 수 있었어요. \\r\\n\\r\\n```tsx\\r\\n// ClientOnly.tsx\\r\\nimport React, { useState, useEffect, ReactNode, FunctionComponent } from 'react'\\r\\n\\r\\ntype ClientProps = {\\r\\n  children: ReactNode\\r\\n}\\r\\n\\r\\nconst ClientOnly: FunctionComponent<ClientProps> = function ({ children }) {\\r\\n  const [isMounted, setIsMounted] = useState<boolean>(false)\\r\\n\\r\\n  useEffect(() => {\\r\\n    setIsMounted(true)\\r\\n  }, [])\\r\\n\\r\\n  if (!isMounted) {\\r\\n    return null\\r\\n  }\\r\\n\\r\\n  return <>{children}</>\\r\\n}\\r\\n\\r\\nexport default ClientOnly\\r\\n```\\r\\n`ClientOnly`를 `HeaderTheme` 컴포넌트의 최상단으로 배치해서 HTML 파일이 모두 성공적으로 load후 토글버튼을 리턴하는 방식으로 이 문제를 해결할 수 있었어요.\\r\\n\\r\\n이건 실제로 제가 해결한 [PR](https://github.com/dobyming/dobyming.github.io/pull/16#issue-1723164020) 이에요.\\r\\n\\r\\n## SVG Icon Flicker Issue \\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/c555ab5e-d15c-482f-925e-ead9b3db00ab/image.gif)\\r\\n\\r\\n이건 GIF를 보면서 설명하면 더 이해가 잘될것 같아요. \\r\\n혹시 `<-` 아이콘이 갑자기 Resizing이 일어나고 그리고 Dark mode Toggle 버튼은 해->달로 잠깐 깜빡이는것을 목격하셨나요? \\r\\n\\r\\n기능은 정상적으로 수행은 되는 버튼이라도, 이런 자잘한 에러들은 UX를 떨어트리는 요소라고 생각했어요. \\r\\n\\r\\n우선 `<-` 버튼 같은 경우는 `fontAwesome`에서 icon을 import하여 사용하고 있었어요. 그리고 이 Resizing 에러가 발생한 원인은 다음과 같았어요.\\r\\n\\r\\n> Instead, they are downloaded through a separate network request and then inserted into the document using Javascript. It’s essentially DOM manipulation, which is how React (which underlies Gatsby) works. Only this time, instead of manipulating UI elements like `<div>`, it is inserting a `<style>` element. Essentially, the styles are downloaded externally and inserted into the document through DOM manipulation. ([출처](https://medium.com/@fabianterh/fixing-flashing-huge-font-awesome-icons-on-a-gatsby-static-site-787e1cfb3a18))\\r\\n\\r\\n요약하면, 해당 icon이 inline하게 HTML에 insert되는게 아니라 `style` 태그로 삽입되어서 **외부적**으로 download가 이뤄진 후에 DOM에 삽입이 되어서 이런 이슈가 발생하는거라고 해요. 즉 Gatsby에선 이 icon이 CSS가 load되어 삽입되기 전에 이미 존재하기 때문에 Resize되는 현상을 목도하게 되는거에요. \\r\\n\\r\\n따라서 이 문제는 icon이 CSS에 Auto Add 되는것을 막으면 해결할 수 있어요. 즉 `inline`하게 설계해야 하는거죠. FontAwesome의 Config setting을 통해 쉽게 해결할 수 있어요. 그러면 build time에 해당 icon이 내장하게 되요. \\r\\n\\r\\n```js\\r\\n// gatsby-browser.js\\r\\nimport '@fortawesome/fontawesome-svg-core/styles.css'\\r\\nimport { config } from '@fortawesome/fontawesome-svg-core'\\r\\n\\r\\nconfig.autoAddCss = false;\\r\\n```\\r\\n<br/>\\r\\n\\r\\n### useEffect와 useLayoutEffect 적절히 사용하기\\r\\n다음으론 다크모드 토글버튼의 상태값이 해->달로 잠깐 보였다가 사라지는 이슈를 해결할 차례예요. 우선 React Developer Tool로 State의 감지를 살펴봤을땐 boolean값이 잠깐 바뀌는 현상이 일어나진 않았어요. \\r\\n\\r\\n그럼 뭐가 문제인걸까 생각했을때, 이벤트가 Trigger되는 시점에 대해서 생각해보게 됐어요. 저는 다크모드 토글이 이뤄지는 이벤트 Trigger를 `useEffect` 리액트 훅을 이용하여 Trigger했었는데, 이에 대적하는 `useLayoutEffect` 리액트 훅에 대해서 알아보기로 했어요. \\r\\n\\r\\n사실 기업 면접에서 `useEffect` 와 `useLayoutEffect`의 차이점을 아세요? 라는 질문을 받았던 경험이 있었는데 슬프게도 대답을 못했고, 또한 사용해보지 않은 Hook 이었기 때문에 이참에 더 알아보기로 했어요. 이 [블로그](https://pubudu2013101.medium.com/what-is-the-real-difference-between-react-useeffect-and-uselayouteffect-51723096dc19)에서 많은 도움을 받았어요.\\r\\n \\r\\n두 리액트 훅의 결정적 차이는 바로 **시점**으로 볼 수 있어요. \\r\\n#### useEffect\\r\\nuseEffect 는 컴포넌트들이 **render 와 paint** 된 후 실행돼요. 즉 비동기적(asynchronous) 으로 실행되고, paint된 후 실행되기 때문에 useEffect 내부에 DOM에 영향을 주는 코드가 있을 경우 사용자 입장에서는 화면의 flicker 현상을 볼 수 있어요. \\r\\n\\r\\n#### useLayoutEffect\\r\\nuseLayoutEffect 는 컴포넌트들이 **render 된 후 실행되며**, 그 이후에 paint 되요. 이 작업은 동기적(synchronous) 으로 실행되며 paint 가 되기전에 실행되기 때문에 DOM을 조작하는 코드가 존재하더라도 사용자는 깜빡임을 경험하지 않아요.\\r\\n\\r\\n\\r\\n```tsx\\r\\n// trigger theme change refer localStorage's key-value\\r\\n  useEffect(() => {\\r\\n    if (userTheme === 'dark') {\\r\\n      document.body.classList.remove('light')\\r\\n      document.body.classList.add('dark')\\r\\n      setIsDark(true)\\r\\n    } else {\\r\\n      document.body.classList.remove('dark')\\r\\n      document.body.classList.add('light')\\r\\n      setIsDark(false)\\r\\n    }\\r\\n  }, [userTheme])\\r\\n```\\r\\n기존 코드를  보면, `document` 객체에 접근하죠? 그리고 `useEffect`로 이를 Trigger하고 있기 때문에 현재 state가 flicker되는 현상을 볼 수 있었던거예요. \\r\\n\\r\\n이때 주의할 점은 `useLayoutEffect`는 paint되기 전에 실행되기 때문에 **React Hydration Issue** 를 만날 수 있는데 (클라이언트화면 !== 서버화면) 이는 상단에 제가 언급한 Minified error와 맞물리기 때문에 해당 validation을 최상단 컴포넌트에서 감아주면 문제를 해결할 수 있어요. \\r\\n\\r\\n### gatsby-plugin-offline 활용하기\\r\\n그리고 추가적으로 `gatsby-plugin-offline` 설치를 하게 되면 깜빡임 현상을 더욱 최소화 할 수 있어요. `gatsby-plugin-offline`은 **Service Worker**를 활용해서 작동합니다. 그럼 서비스워커는 무엇일까요?\\r\\n> 서비스 워커는 웹 응용 프로그램, 브라우저, 그리고 (사용 가능한 경우) 네트워크 사이의 프록시 서버 역할을 합니다. 서비스 워커의 개발 의도는 여러가지가 있지만, 그 중에서도 효과적인 오프라인 경험을 생성하고, 네트워크 요청을 가로채서 네트워크 사용 가능 여부에 따라 적절한 행동을 취하고, 서버의 자산을 업데이트할 수 있습니다. 또한 푸시 알림과 백그라운드 동기화 API로의 접근도 제공합니다. (출처: [MDN](https://developer.mozilla.org/ko/docs/Web/API/Service_Worker_API))\\r\\n\\r\\n![gatsby-service-worker](https://github.com/dobyming/dobyming.github.io/assets/90133704/9ab3f2eb-f665-4c5c-aeec-9f83ee2264da)\\r\\n\\r\\n페이지를 최초 요청할때 static한 asset들(SVG Icon)을 내려 받고, CacheStorage에 저장을 합니다. 따라서 유저가 향후 웹사이트를 재방문할때 유저의 Cache Storage에 저장된 assets들을 참고하여, 빠르게 불러올 수 있습니다. 그렇기 때문에 깜빡임 현상을 최소화 할 수 있습니다. \\r\\n\\r\\n이때 config options를 통해서 어느 페이지 또는 어떤 폴더에 대해서만 Cache에 담을 지 부여할 수 있어요. 이 Option이 필요한 이유는 역시 사용자 경험과 밀접한 연관을 맺고 있어요. 만약 최초로 방문하는 유저일 경우에는 모든 리소스들을 Cache에 담는 작업이 수행된다면, 사용자별로 Cache 사이즈도 상이하고 그리고 Band-width도 상이하기 때문에 어떤 환경에서는 빠를지 몰라도, 또 다른 유저는 느리게 느껴질 수도 있어요. \\r\\n\\r\\n따라서 아래와 같이 내가 어떤 상황에서만 cache작업을 하겠다는 것을 부여할 수 있습니다. \\r\\n```js\\r\\n{\\r\\n    resolve: `gatsby-plugin-offline`,\\r\\n    options: {\\r\\n        precachePages: [`/blog/*`],\\r\\n    },\\r\\n}\\r\\n```\\r\\n\\r\\n### 결과물\\r\\n위 과정들을 거치고 나면..!\\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/c03d5350-d60b-44e2-a565-04f092e6f3b2/image.gif)\\r\\n\\r\\n더이상은 해로 잠깐 보였다가 사라지는 현상은 볼 수 없게 되요😙\\r\\n\\r\\n## Ongoing..\\r\\nGatsby로 이것저것 접목해서 블로그를 만들면서 가장 많이 접한 개념은 브라우저의 작동방식이었어요. 실제로 개발을 진행하면서 CSR, SSR, SSG와 같이 렌더링에 대한 개념을 기존보다 더 딥하게 체감하며 개념의 중요성을 깨달을 수 있었던 좋은 트러블 슈팅을 경험했다고 생각해요. \\r\\n\\r\\n### +) 23.05.29 LightHouse 점수 💯\\r\\n![](https://velog.velcdn.com/images/damin1025/post/89bfd0af-9bac-4670-b46e-c27acc9d1d00/image.PNG)\\r\\n\\r\\nPerformance에서 2점이 부족한데.. 400점을 받는 그날까지 계속해서 성능 튜닝을 진행할 예정입니닷..!👊\\r\\n\\r\\n### 🙇🏼‍♀️참고\\r\\n**React Hydration Issue**\\r\\n\\r\\nhttps://www.codeandweb.com/tutorials/gatsby-lazy-loading-with-react-lazy\\r\\n\\r\\nhttps://egghead.io/lessons/react-avoiding-state-flickers-in-gatsby-applications\\r\\n\\r\\nhttps://vaihe.com/blog/fixing-gatsby-hydration-flicker-issue/\\r\\n\\r\\n**Gastby SSR Issue(함께 읽으면 좋음)**\\r\\n\\r\\nhttps://stackoverflow.com/questions/64371186/gatsby-window-not-available-during-server-side-rendering-build-error\\r\\n\\r\\nhttps://www.gatsbyjs.com/docs/debugging-html-builds/#how-to-check-if-window-is-defined\",\"n\":0.032}}},{\"i\":15,\"$\":{\"0\":{\"v\":\"Gatsby 블로그 - 다크모드 구현기🌗\",\"n\":0.447},\"1\":{\"v\":\"\\r\\n우선 글을 시작하기 전에.. 5월 24일 부로 블로그 개발을 시작한지 1달 넘은 시점에서 100개의 commit을 달성했습니다..🥳\\r\\n\\r\\n<div style=\\\"text-align:center\\\"><img src=\\\"https://velog.velcdn.com/images/damin1025/post/0e0117f4-e670-4a3c-a849-c5eadf34c786/image.PNG\\\" /></div>\\r\\n\\r\\n\\r\\n저에게 이 `개발 블로그` 프로젝트는 **프론트엔드가 뭔지 제대로 보여준** 프로젝트나 다름 없어서 배운게 정말 많은 고마운 프로젝트입니다. 만약 프론트엔드를 내 커리어패스로 밟고 싶다고 한다면 자신만의 블로그 만드는 것을 적극 추천할 정도로 배울게 정말 많고 좋은 프로젝트라고 생각합니다. \\r\\n\\r\\n사족은 여기서 마무리 짓고.. 다크모드를 구현하면서 겪은 제 삽질기를 나열해보겠습니다 🤪...\\r\\n\\r\\n\\r\\n## 동기 \\r\\n이 프로젝트를 처음 구상하고 그리고 기능들을 하나씩 만들어 나갈때 세운 목표 중 하나가 다크모드는 꼭 만들어야지..! 생각했습니다. 특히 프론트엔드에서 이제 없으면 허전할 정도라고 볼 수 있는 **다크모드🌗** 기능을 Gatsby와 어느정도 친해지면 제대로 파야겠다 생각했고 때가 온 것이었습니다. \\r\\n\\r\\n일전에 React를 배우기 위해서 [Emotionary](https://github.com/dobyming/Emotionary) 프로젝트를 진행 중, `Provider` 개념을 활용하여 최상위 컴포넌트에서 `theme` props를 전달하여 다크모드를 구현했던 경험이 있었고, Gatsby에서도 이런 개념을 활용하면 되려나? 생각으로부터 시작하며 구현에 Dive 했습니다. \\r\\n\\r\\n## Theme을 어떻게 전달할 것인가 : ThemeProvider VS CSS Variable\\r\\n대략적인 Mock Up은 이렇게 구상했었습니다.\\r\\n>토글 버튼이 있음(component) -> 클릭 값(state)에 따라 어떤 theme을 보여줄지 결정할 것. (boolean 속성으로 true면 dark, false면 light) \\r\\n\\r\\n그리고 이때 `theme`을 어떻게 전달할 것인가? 이게 관건이었습니다.  \\r\\n\\r\\n### 🤔 emotion의 ThemeProvider로 삽질 \\r\\n~~오래전에 수행한 삽질이라 기억이 약간 가물하네요...ㅠ~~\\r\\n\\r\\n기존에 `Provider`를 활용하여 구현해 본 경험이 있었기 때문에 마침 `emotion`에서 `ThemeProvider` Theme package를 지원하고 있었고 저 역시 이걸로 구현해야겠다 생각하며 코드 구현에 진행했지만, ... build는 커녕 develop 단계에서부터 error를 만나게 되어 머리를 싸맸습니다.\\r\\n\\r\\n### 🥰 CSS Variable로 광명을 찾다 \\r\\n'토글 버튼의 클릭 값에 따라 어떤 theme을 보여줄 지..' 이 문장에서 CSS Variable과 엮을 수 있습니다. \\r\\n\\r\\n```tsx\\r\\n// trigger theme change refer localStorage's key-value\\r\\n useLayoutEffect(() => {\\r\\n\\tif (userTheme === 'dark') {\\r\\n    document.body.classList.remove('light')\\r\\n    document.body.classList.add('dark')\\r\\n    setIsDark(true)\\r\\n\\t} else {\\r\\n    document.body.classList.remove('dark')\\r\\n    document.body.classList.add('light')\\r\\n    setIsDark(false)\\r\\n    }\\r\\n }, [userTheme])\\r\\n```\\r\\n여기서 `userTheme`이 현재 state이고, 그 state가 `dark`라면 `body` 태그의 className을 `dark`라고 지정하고, 그 반대면 `light`로 지정합니다. \\r\\n\\r\\n그러면 이 `body` 태그의 className에 따라서 CSS Variable로 지정할 수 있었습니다.   \\r\\n```css\\r\\n/*theme.css*/\\r\\n\\r\\n.light {\\r\\n    --color-background:#f6f6f6;\\r\\n}\\r\\n\\r\\n.dark {\\r\\n    --color-background: #25262c;\\r\\n    --color-text: #f6f6f6;\\r\\n}\\r\\n\\r\\nbody {\\r\\n    background-color: var(--color-background);\\r\\n    transition: 0.2s;\\r\\n}\\r\\n\\r\\nh1,\\r\\nh2,\\r\\nh3,\\r\\nh4,\\r\\nh5,\\r\\nhr,\\r\\na,\\r\\np,\\r\\nli,\\r\\ntd,\\r\\ntr,\\r\\nfooter,\\r\\nspan {\\r\\n  color: var(--color-text);\\r\\n}\\r\\n```\\r\\n`theme.css` 파일에 위와 같이 정의할 수 있습니다. 상단에는 body의 className에 따라서 어떤 css 속성 값을 부여할 지 rgb 값을 정의합니다. 그리고 **원하는 태그에 원하는 CSS Variable**을 지정할 수 있습니다. 이런 로직으로 수행하면 전체적으로 개발 블로그에 다크모드가 적용됨을 볼 수 있습니다. \\r\\n\\r\\n그리고 실제로 Provider를 활용해 다크모드를 구현하는 것보단, CSS Variable을 활용하여 구현한 것이 **성능적인** 측면에서도 더 좋은 지표를 보여줬습니다. \\r\\n[Dark Mode Theme PR](https://github.com/dobyming/dobyming.github.io/pull/11) 해당 링크로 가시면 제가 왜 CSS Variable을 선택하여 구현에 진행했는지 자세한 지표와 설명을 볼 수 있습니다. \\r\\n\\r\\n>+) 추가로 SVG Icon에 다크모드를 어떻게 적용해야 할 지 막막한 분들께 간략한 코드를 보여드리고자 합니다. (사실 내가 바보여서 헷갈려했음..)\\r\\n\\r\\n우선 SVG 같은 경우에는 색상이 담길 수 있도록 `fill`과 `stroke` 속성을 지정 해야합니다. `fill`은 채워지는 색이고 `stroke`는 테두리색입니다. 그러므로 `.svg` 파일에서 **`path` 태그 내에 fill과 stroke 속성을 current**로 지정합니다.\\r\\n\\r\\n```svg\\r\\n// 예시 svg\\r\\n<svg width=\\\"30px\\\" height=\\\"30px\\\" viewBox=\\\"0 0 24 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\r\\n<path fill=\\\"current\\\" stroke=\\\"current\\\" fill-rule=\\\"evenodd\\\" clip-rule=\\\"evenodd\\\" d=\\\"M15.7071 4.29289C16.0976 4.68342 16.0976 5.31658 15.7071 5.70711L9.41421 12L15.7071 18.2929C16.0976 18.6834 16.0976 19.3166 15.7071 19.7071C15.3166 20.0976 14.6834 20.0976 14.2929 19.7071L7.29289 12.7071C7.10536 12.5196 7 12.2652 7 12C7 11.7348 7.10536 11.4804 7.29289 11.2929L14.2929 4.29289C14.6834 3.90237 15.3166 3.90237 15.7071 4.29289Z\\\" fill=\\\"#000000\\\"/>\\r\\n</svg>\\r\\n```\\r\\n\\r\\n그럼 색상을 지정하고자 하는 SVG Icon에 className을 부여한 후, 자신이 정의한 theme css 파일에 마찬가지로 CSS Variable로 지정하면 끝입니다! \\r\\n```css\\r\\n.githubIcon path {\\r\\n    fill: var(--color-text);\\r\\n}\\r\\n```\\r\\n\\r\\n## Flicker Issue 에러 해결하기\\r\\n다크 모드 구현에 대한 틀을 잡았다는 기쁨도 잠시, 페이지를 reload 시  분명 이런 깜빡임 현상을 겪을 것입니다...\\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/58ff2ef6-95a9-4fea-b04d-3520fb34a879/image.gif)\\r\\n\\r\\n못봤다구요? 저도 그냥 잠시 일시적으로 아주 잠깐 이러는거 아닐까..? ㅎㅎ 했는데 아니더라구요 😣 아주 유명한 <span style=\\\"color:red\\\">**Flicker Issue**</span> 였습니다. \\r\\n\\r\\n>The problem is that the HTML is generated long before it reaches the user's device, so there's no way to know which color theme the user prefers. [참고](https://www.joshwcomeau.com/css/css-variables-for-react-devs/#dark-mode-flash-fix)\\r\\n\\r\\n해당 Issue가 발생한 원인으로는, Gatsby가 HTML 파일을 빌드하는 `Pre-Render` 특성과 밀접한 관련이 있습니다. 비록 localStorage로 사용자가 설정한 theme을 저장한다고 해도, **reload 시 localStorage를 참조하는건 Pre-Render 시점이 아닌 그 이후 시점에 참조**하기 때문에 이런 현상이 발생하게 됩니다. \\r\\n\\r\\n즉 이 문제를 해결하기 위해서는, localStorage를 참조하는 시점을 DOM 트리가 구축되기 이전에 Script 파일을 강제로 Injection하는 부분의 코드 작업이 필요했습니다. 그리고 Gatsby에서는 **`html.js` 파일을 통해 Script 파일을 inject 할 수 있도록 customize**를 허용합니다. \\r\\n\\r\\n>💖 [Gatsby html.js customize](https://www.gatsbyjs.com/docs/custom-html/) docs에 `html.js` 파일을 생성하는 부분에 대해 자세한 설명이 있으므로 꼭 docs를 읽으시고 진행하시길!!\\r\\n\\r\\n그럼 `html.js` 파일이 생성됐고, 저는 아래와 같이 customize를 진행했습니다. \\r\\n```js\\r\\n// html.js\\r\\nimport React from 'react'\\r\\nimport PropTypes from 'prop-types'\\r\\n\\r\\nexport default class HTML extends React.Component {\\r\\n  render() {\\r\\n    return (\\r\\n      <html {...this.props.htmlAttributes}>\\r\\n        <head>\\r\\n          <meta charSet=\\\"utf-8\\\" />\\r\\n          <meta httpEquiv=\\\"x-ua-compatible\\\" content=\\\"ie=edge\\\" />\\r\\n          <meta\\r\\n            name=\\\"viewport\\\"\\r\\n            content=\\\"width=device-width, initial-scale=1, shrink-to-fit=no\\\"\\r\\n          />\\r\\n          {this.props.headComponents}\\r\\n        </head>\\r\\n        <body {...this.props.bodyAttributes} className=\\\"light\\\">\\r\\n          <script\\r\\n            dangerouslySetInnerHTML={{\\r\\n              __html: `\\r\\n\\t\\t\\t// Customize 할 부분\\r\\n              (function () {\\r\\n                try {\\r\\n                  var mode = localStorage.getItem('color-theme');\\r\\n                  if (!mode) return;\\r\\n                  document.body.classList.add(mode);\\r\\n                } catch (e) {}\\r\\n              })();\\r\\n            `,\\r\\n            }}\\r\\n          />\\r\\n          {this.props.preBodyComponents}\\r\\n          <div\\r\\n            key={`body`}\\r\\n            id=\\\"___gatsby\\\"\\r\\n            dangerouslySetInnerHTML={{ __html: this.props.body }}\\r\\n          />\\r\\n          {this.props.postBodyComponents}\\r\\n        </body>\\r\\n      </html>\\r\\n    )\\r\\n  }\\r\\n}\\r\\n\\r\\nHTML.propTypes = {\\r\\n  htmlAttributes: PropTypes.object,\\r\\n  headComponents: PropTypes.array,\\r\\n  bodyAttributes: PropTypes.object,\\r\\n  preBodyComponents: PropTypes.array,\\r\\n  body: PropTypes.string,\\r\\n  postBodyComponents: PropTypes.array,\\r\\n}\\r\\n```\\r\\nDOM 트리가 구축되기 직전에 localStorage를 참조하여 미리 Theme이 setting 될 수 있도록 Script를 주입했습니다. 아래와 같이 해당 Dark mode flicker issue를 해결할 수 있었습니다. \\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/9818ade3-3dbd-4eca-a24f-0eaf7c0f70a1/image.gif)\\r\\n\\r\\n실제 deploy된 element 코드를 보면 script injection이 잘 됐음을 볼 수 있습니다. \\r\\n\\r\\n![](https://velog.velcdn.com/images/damin1025/post/c6c1144e-5caa-490d-b842-7ee175488c7c/image.PNG)\\r\\n\\r\\n## 🔮 Utterance에 다크모드 적용하기 \\r\\n제 개발 블로그에는 댓글 기능으로 `Utterance` 오픈 소스를 활용하고 있습니다. \\r\\n\\r\\n이때 Utterance는 다른 요소들과는 달리, `Div` element를 직접 생성하고 그리고 `attributes`에 repo 등등 속성을 지정하고 그리고 그 지정한 값에 대해서 DOM 트리에 appendChild 하여 생성되기 때문에 다크모드 구현에 대해 CSS Variable로 어떻게 지정해야 되는지 구상이 잘 떠오르지 않았습니다.\\r\\n\\r\\nUtterance 요소는 `Div`로 생성되지 않고 `iframe`으로 생성됩니다. \\r\\n따라서 `iframe` 태그에 접근하여 theme을 바꾸는 부분을 `window.postMessage()`로 전달하여 접근했어야 했습니다.\\r\\n\\r\\n> `window.postMessage()` 메소드는 Window 오브젝트 사이에서 안전하게 cross-origin 통신을 할 수 있게 합니다. 예시로, 페이지와 생성된 팝업 간의 통신이나, 페이지와 페이지 안의 iframe 간의 통신에 사용할 수 있습니다. (출처: [MDN](https://developer.mozilla.org/ko/docs/Web/API/Window))\\r\\n\\r\\n제 프로젝트에서 **다크모드의 전환 유무의 포인트는 body의 className**입니다. light냐 dark냐에 따라서 DOM 트리가 구축될때, body의 className에 따라 유동적으로 변화할 수 있는 idea가 필요했습니다. 구글링 결과, `MutationObserver` 라는 Constructor가 이 개념을 활용할 수 있다고 판단했습니다. [참고](https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/)\\r\\n\\r\\n```tsx\\r\\nuseEffect(() => {\\r\\n    const mutationObserver: MutationObserver = new MutationObserver(\\r\\n      mutationsList => {\\r\\n        mutationsList.forEach(mutation => {\\r\\n          if (mutation.attributeName === 'class') {\\r\\n            if (window.document.querySelector('.utterances-frame')) {\\r\\n              const theme = mutation.target.classList.contains('dark')\\r\\n                ? 'photon-dark'\\r\\n                : 'github-light'\\r\\n              const message = {\\r\\n                type: 'set-theme',\\r\\n                theme: theme,\\r\\n              }\\r\\n              const iframe =\\r\\n                window.document.querySelector('.utterances-frame')\\r\\n              iframe.contentWindow.postMessage(message, src)\\r\\n            }\\r\\n          }\\r\\n        })\\r\\n      },\\r\\n    )\\r\\n    mutationObserver.observe(document.body, { attributes: true })\\r\\n  }, [])\\r\\n```\\r\\n감지된 body의 className에 따라 삼항연산자로 theme을 할당 후, iframe에 postMessage()로 message를 전달합니다. 그리고 `attributes`의 상태값을 true로 지정하여, body의 class의 변화를 감지할 수 있도록 수행합니다. \\r\\n또한 이 이벤트를 mount 시점에 trigger 될 수 있도록 `useEffect()` Hook내에 선언했습니다. 이는 index(홈 화면)에서 다크 모드로 토글 후, 포스트를 클릭하여 utterance theme이 바로 적용될 수 있도록 하기 위함입니다. \\r\\n\\r\\n### 결과물\\r\\n![](https://velog.velcdn.com/images/damin1025/post/c7799ac4-2bbe-466e-95ca-d1c33a3a491e/image.gif)\\r\\n\\r\\n휴 .. 개인적으로 어려웠던 부분 중 하나였는데 잘 작동해서 어찌나 행복하던지💙\\r\\n\\r\\n\\r\\n## 마무리 \\r\\n사실 이 글을 쓰면서 엥 이것밖에 안된다고? 생각이 들 정도로, 다크모드 구현은 꽤나 복잡하고 그리고 꼼꼼함을 기울이는 작업이었습니다. 아무래도 사용자 경험에 큰 영향을 미치는 요소이기 때문에 더욱이 신경을 쓸 수 밖에 없었던 작업이었습니다.  \\r\\n\\r\\n어떤 기술을 선택해야 할지, 그리고 어떤 태그에 색상 변화가 필요한지, 또한 렌더링 이슈도 handling 했어야 했고 정말.. 오랜 작업 끝에 어느정도 구색을 갖춘것 같습니다.. (4월말부터 시작했으니..) \\r\\n\\r\\n저도 처음으로 제대로 각잡고 만든 다크모드라 부족한 점이 있을 수도 있습니다😂 피드백은 언제나 환영입니다! \\r\\n\\r\\n### 🙇🏼‍♀️ 참고 \\r\\n**-다크모드 CSS Variable 및 flicker Issue-**\\r\\n\\r\\nhttps://blog.maximeheckel.com/posts/switching-off-the-lights-part-2-fixing-dark-mode-flashing-on-servered-rendered-website/\\r\\n\\r\\nhttps://blog.rhostem.com/posts/2020-06-25-dark-mode-for-gatsby-website\\r\\n\\r\\nhttps://github.com/gaearon/overreacted.io/blob/master/src/html.js\\r\\n\\r\\n**-Utterance dark mode-**\\r\\n\\r\\nhttps://www.sungikchoi.com/blog/gatsby-dark-mode/\\r\\n\\r\\n**-MutationObserver-**\\r\\n\\r\\nhttps://mong-blog.tistory.com/entry/JS-DOM%EC%9D%84-%EA%B0%90%EC%8B%9C%ED%95%98%EB%8A%94-MutationObserver\\r\\n\\r\\nhttps://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/\\r\\n\\r\\nhttps://developer.chrome.com/blog/detect-dom-changes-with-mutation-observers/\\r\\n\\r\\nhttps://stackoverflow.com/questions/31659567/performance-of-mutationobserver-to-detect-nodes-in-entire-dom\\r\\n\",\"n\":0.03}}}]}","data":[{"id":"dfab372a-5b43-535f-bc42-189bbf8a614a","path":"/about/resume/","title":"resume","body":"# 김다민(Damin Kim)\r\n\r\n<div align=\"right\"><sub><i>Last updated: 2023.07.09</i></sub></div>\r\n\r\n## 안녕하세요, 끊임없이 도전하는 개발자 김다민입니다.\r\n\r\n웹 브라우저의 세계가 커짐에 따라 상상을 현실로 실현할 수 있는 프론트엔드 분야를 애정합니다. 늘 **사용자 관점에서 프로젝트를 바라보려 노력**하고 **UX를 높일 수 있는 방향성을 끊임없이 고민**하는데 큰 재미를 느끼고 있습니다.\r\n\r\n**다양한 의견을 적극적으로 수용하고 끊임없는 도전정신으로 문제 해결에 주력**하며 꾸준한 성장을 도모하는 프론트엔드 개발자로 함께 하고 싶습니다.\r\n\r\n# Experiences\r\n## 🚚 Hanjin Co Ltd. - Project Team\r\n*DevOps Frontend Developer as Intern Seoul, South Korea – (Aug 2022 - Dec 2022)* \r\n\r\n### Projects\r\n애자일 방식의 차세대 간선 시스템 프로젝트 - 프론트엔드 파트 개선 및 개발 작업 수행 \r\n(***Stack : eXbuilder6, JavaScript(ES6), React, Docker, Redis, Kafka***)\r\n\r\n- **[feature] 유저 Role에 따른 버튼(기능) 권한 부여 작업**\r\n    - 로그인 시, JSON 값으로 부여되는 권한 코드에 따른 버튼(기능) 권한 이벤트 함수를 구현하고 전체 페이지에 적용\r\n- **[feature] 미아편명 팝업 페이지 구현**\r\n    - 백엔드 개발자와 페어코딩을 통해, 팝업 버튼을 클릭 시 API가 호출되면서 팝업화면에 대체 가능한 편명을 조회 및 저장하는 기능 구현\r\n    - UX를 고려하여, 선택된 대체 편명이 없을때 저장 시도 시 alert 메시지를 띄우는 작업 수행\r\n    - 대체할 편명과 대체될 편명이 똑같을 경우 팝업창이 그대로 닫히지 않고 focus될 수 있도록 validation check 기능 구현\r\n- **[feature] 요율, 터미널별 권역 페이지 구현**\r\n    - 백엔드 개발자와 페어코딩을 통해 각 터미널 별 비용을 CRUD 할 수 있는 기능과 전체적인 UI mock-up 진행\r\n    - 엑셀로 업무를 수행하는 본사팀의 업무 관례를 고려하여, SheetJS를 통해 한번에 요율과 권역을 시스템에 업로드 및 저장할 수 있는 기능 구현\r\n- **[Improvement] 조업사 모바일 플랫폼 UX 증진 작업**\r\n    - 상/하차 페이지에서 (상하차작업 리스트) 운행완료 건들을 색깔로서 구분될 수 있도록 작업 수행\r\n    - 운행이 완료된 작업들은 리스트의 맨밑으로 이동될 수 있도록 sort 수행\r\n    - 조업사의 하루 기준에 맞춰 달력에 default로 날짜가 setting 될 수 있도록 Moment.js를 통해 작업 수행 (하루 기준 : 당일 10:00 AM ~ d+1 9:59 AM).\r\n\r\n# Side Projects\r\n[이 사이트](https://url.kr/qlcrmf)로 접속 시, 저의 Side Project를 확인하실 수 있습니다.\r\n\r\n# Skills\r\n### Front-End\r\n- HTML, CSS, JavaScript, TypeScript, Emotion\r\n- NPM, WebPack\r\n- React, React-Native, GatsbyJS, GraphQL\r\n\r\n### Back-End & Server\r\n- Python\r\n- NodeJS, ExpressJS\r\n- Nginx, Axios, Ajax\r\n- MySQL\r\n\r\n### DevOps\r\n- Firebase, Firebase Auth, Github Pages\r\n- AWS (EC2, S3, CodePipeline)\r\n\r\n### Collaboration\r\n- VS Code, IntelliJ, PyCharm\r\n- Git, Github, AWS CodeCommit\r\n- Google Space, Redmine\r\n\r\n# Education\r\n## 인하대학교(Inha University) \r\n*컴퓨터공학과(Bachelor of Computer Engineering) - (Mar 2020 ~ Feb 2023)*"},{"id":"88750ab1-b392-580f-94b0-09a214040da1","path":"/TIL/gatsby-request/","title":"Gatsby - GraphQL로 query 요청하기","body":"\r\n## GraphQL이란?\r\nGraphQL은 페이스북에서 개발한 **쿼리 언어**입니다.\r\n각각의 엔드포인트에서 고정된 데이터를 받을 수 있는 Rest API와는 다르게 GraphQL은 <span style=\"color:red\">**단일 엔드포인트**</span>에서 원하는 데이터만을 받을 수 있다는 장점을 가지고 있습니다.\r\n\r\n정적 웹사이트의 콘텐츠 데이터를 관리하는데 있어 GraphQL로 진행할 수 있습니다. \r\n\r\n## Gatsby에서 GraphQL을 사용하는 방법\r\n\r\n그럼 Gatsby에서 GraphQL로 query로 요청해서 웹사이트로 값을 불러오는 방법에 대해서 알아보겠습니다. \r\n\r\n우선 `pages` 폴더 내에 `info.tsx`를 선언합니다. \r\n\r\n```tsx\r\nimport React, { FunctionComponent } from 'react'\r\nimport { graphql } from 'gatsby'\r\nimport Text from 'components/Text'\r\n\r\ntype InfoPageProps = {}\r\n\r\nconst InfoPage: FunctionComponent<InfoPageProps> = function () {\r\n  return (\r\n    <div>\r\n      <Text text=\"Hello\" />\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default InfoPage\r\n```\r\n일반적인 컴포넌트에서는 변수로서 정의가 불가능하고, **StaticQuery**라는 기능을 통해 정의가 가능합니다. pages 폴더 내부에 있는 컴포넌트에서는 다음과 같이 Query를 정의하고 요청할 수 있습니다.\r\n\r\n```tsx\r\nimport React, { FunctionComponent } from 'react'\r\nimport { graphql } from 'gatsby'\r\nimport Text from 'components/Text'\r\n\r\ntype InfoPageProps = {}\r\n\r\nconst InfoPage: FunctionComponent<InfoPageProps> = function () {\r\n  return (\r\n    <div>\r\n      <Text text=\"Hello\" />\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default InfoPage\r\n\r\n// query 요청 부 \r\nexport const metadataQuery = graphql`\r\n  {\r\n    site {\r\n      siteMetadata {\r\n        title\r\n        description\r\n        author\r\n      }\r\n    }\r\n  }\r\n`\r\n```\r\n\r\n`metadataQuery` 변수에 요청한 Query를 요청 시, 요청에 대한 응답 값은 `InfoPage` 컴포넌트의 Props로 전달해줍니다. 마지막으로 `InfoPage` 컴포넌트의 매개변수로 값을 불러오면서 Gatsby에서 GraphQL을 통한 Query 요청 작업이 마무리 됩니다. \r\n```tsx\r\nimport React, { FunctionComponent } from 'react'\r\nimport { graphql } from 'gatsby'\r\nimport Text from 'components/Text'\r\n\r\n// 요청한 Query의 데이터 구조에 따라 type을 지정 \r\ntype InfoPageProps = {\r\n  data: {\r\n    site: {\r\n      siteMetadata: {\r\n        title: string\r\n        description: string\r\n        author: string\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// 매개변수로 요청한 Query를 Props로 전달 \r\nconst InfoPage: FunctionComponent<InfoPageProps> = function ({\r\n  data: {\r\n    site: {\r\n      siteMetadata: { title, description, author },\r\n    },\r\n  },\r\n}) {\r\n  return (\r\n    <div>\r\n      <Text text={title} />\r\n      <Text text={description} />\r\n      <Text text={author} />\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default InfoPage\r\n\r\nexport const metadataQuery = graphql`\r\n  {\r\n    site {\r\n      siteMetadata {\r\n        title\r\n        description\r\n        author\r\n      }\r\n    }\r\n  }\r\n`;\r\n```\r\n\r\n이와 같이 Gatsby에서 GraphQL을 통해 데이터를 요청하고 응답받는 과정을 수행할 수 있습니다. "},{"id":"70aed9e7-4c38-511c-9220-59edbfd69464","path":"/TIL/js-function/","title":"JavaScript - 함수","body":"### 함수\r\n\r\n-**함수 선언식 vs 함수 표현식 차이**\r\n\r\n```jsx\r\nconsole.log(helloDelcare()); // '안녕하세요 함수 선언식입니다'\r\nconsole.log(hello); // error : 'hello is not a function'\r\n\r\nfunction helloDelcare() {\r\n\treturn '안녕하세요 함수 선언식입니다'\r\n}\r\n\r\nlet hello = function helloRepresent() {\r\n\treturn '안녕하세요 함수 표현식 입니다.'\r\n}\r\n```\r\n\r\n1) 함수 선언식: **Hoisting**(쉽게 말하면 밑에서 선언한 함수를 코드의 상단에서 호출해도 출력이 이루어짐)이 일어나는 방식 \r\n\r\n2) 함수 표현식: **Hoisting**의 대상이 되지 않음 ⇒ 즉 `hello` 변수를 표현하면서 부터 함수가 생성되기 때문에, 상단에서 hello를 log로 찍으려고 하면 **에러**가 발생.\r\n→ 따라서 함수를 먼저 선언 후, 표현식에 선언된 변수를 호출해야 정상적으로 값을 찍을 수 있다. \r\n\r\n**-arrow function (함수 표현식을 간단히 표현하는 방법)**\r\n\r\n```jsx\r\nlet hello = () => {\r\n\treturn '안녕하세요'\r\n}\r\n// '() =>' 표현과 동일한 예약어가 'function 함수명()' 이라고 생각하면 됌 \r\n```\r\n\r\n화살표 함수는 쉽게 생각하면 함수 표현식에서 keyword `function` **만 삭제**한 문법이라고 생각하면 된다. (역시 Hoisting의 대상이 아님)\r\n\r\n>-콜백함수\r\n```jsx\r\nfunction checkMood(mood) {\r\n\tif (mood === \"good\") {\r\n\t\t// ...\r\n\t\tsing()\r\n\t} else {\r\n\t\t// ...\r\n\t\tcry()\r\n\t}\r\n}\r\n\r\nfunction cry() {\r\n\tconsole.log('Action : CRY');\r\n}\r\n\r\nfunction sing() {\r\n\tconsole.log('Action : SING');\r\n}\r\n\r\nfunction dance() {\r\n\tconsole.log('Action: DANCE');\r\n}\r\n\r\ncheckMood(\"good\"); \r\n```\r\n\r\n기존 동작 방식\r\n\r\n1. `checkMood` 함수가 good이라는 매개변수를 전달 받는다.\r\n2. good이면 `sing` 함수를 호출해서 console 로그가 찍힌다.\r\n\r\n>**콜백함수의 등장 배경** \r\n만약 어떤 함수에서 특정 기능을 사용하고 싶은데, 일일이 body안에 메소드를 선언해줘야 한다면.. 코드 유지보수성이 매우 떨어진다.  \r\n따라서 만약 함수(`checkMood`) 파라미터에 함수(`sing` , `cry` , `dance`)를 넘겨주면 매개변수로는 **함수의 표현식** 처럼 작동하게 됩니다. \r\n\r\n```jsx\r\nfunction checkMood(mood,goodCallback,badCallback) {\r\n\tif (mood === \"good\") {\r\n\t\t// ...\r\n\t\tgoodCallback()\r\n\t} else {\r\n\t\t// ...\r\n\t\tbadCallback()\r\n\t}\r\n}\r\n\r\nfunction cry() {\r\n\tconsole.log('Action : CRY');\r\n}\r\n\r\nfunction sing() {\r\n\tconsole.log('Action : SING');\r\n}\r\n\r\nfunction dance() {\r\n\tconsole.log('Action: DANCE');\r\n}\r\n\r\ncheckMood(\"good\",sing,cry); \r\n```\r\n\r\n다음과 같이 구성한 코드를 콜백함수라고 합니다. 콜백함수는 비동기함수에서 중요한 개념으로 쓰입니다. "},{"id":"95b9e1bc-62a3-54a3-8c10-d54cdd51bd8c","path":"/TIL/gatsby-page-route/","title":"Gatsby에서 페이지 라우팅 하는법","body":"\r\n## Gatsby에서 페이지 라우팅하기 \r\n\r\nGatsby에서 페이지간 라우팅 하는 방식은 2가지가 있습니다. \r\n\r\n첫번째는 `a` 태그를 활용하는 것입니다. pages 폴더 내에 선언된 파일들은 '/파일명'으로 페이지 간 이동이 가능합니다. \r\n하지만 React 기반으로 설계된 프레임워크인 Gatsby를 감히 매번 페이지 이동 시, refresh 되게 구현하면... 이걸로 왜 개발 하냐구요 (UX도 매우 저하되구요) \r\n\r\n\r\n## Gatsby Link API 활용하기 \r\n\r\nGatsby에서 제공하는 페이지 이동 API인  <span style=\"color:red\">Gatsby Link API</span>을 활용하여 페이지 간 라우팅을 구현할 수 있습니다. 이 API를 통해 페이지 이동을 구현하면 보다 더 높은 성능의 정적 사이트를 구현할 수 있습니다.\r\n\r\n### Usage\r\n```tsx\r\nimport { Link } from 'gatsby'\r\n<Link to=\"/info/\">To Info</Link>\r\n```\r\n기본적인 사용방법은 위와 같습니다. `Link`를 import 후, Link 태그의 to의 props로 이동할 페이지명을 적어주면 됩니다. \r\n\r\n해당 방식으로 구현 시, a 태그를 사용했을때보다 Link태그를 활용하여 페이지 간 라우팅 방식이 훨씬 더 매끄럽고 속도도 향상됨을 체감할 수 있을 것 입니다. \r\n\r\n그러면 우리는 왜 이럴 수 있는지에 대한 근거까지 알아봐야겠죠\r\n\r\n### Gatsby Link API의 성능상 이점\r\n궁극적인 근거는 Gatsby는 **Prefetch**를 통해서 페이지에서 사용할 리소스의 로딩 속도를 높일 수 있습니다. \r\n\r\n즉 Prefetch는 이와 같은 개념입니다. \r\n\r\n1. 페이지가 로드가 됌 -> 현재 로드된 페이지 내에서 사용되는 모든 링크 찾은 후 -> 각 링크의 페이지를 <span style=\"color:red\">미리</span> 로드 \r\n2. 즉 예를 들면, `index.tsx` 페이지 로드가 됨 -> 동시에 `Link` 태그를 찾음(`/info`) -> 이 페이지(`info`)를 미리 로드해둠 \r\n\r\n"},{"id":"a6d41dee-de2d-5b58-b234-56017b6e5fb5","path":"/TIL/js-sync-async/","title":"JavaScript - 동기와 비동기 처리","body":"\r\n## 동기와 비동기 (Synchronus , Asynchronus)\r\n이번 포스팅에선 자바스크립트의 2가지 동작 방식인 동기와 비동기처리에 대해서 다뤄\r\n보겠습니다.\r\n\r\n함수 3개를 호출했을때를 예로 들어보겠습니다.\r\n\r\n```jsx\r\nfunction taskA() {\r\n  console.log('Task A');\r\n}\r\nfunction taskB() {\r\n  console.log('Task B');\r\n}\r\nfunction taskC() {\r\n  console.log('Task C');\r\n}\r\n\r\n//함수 호출 \r\ntaskA();\r\ntaskB();\r\ntaskC();\r\n```\r\n\r\n함수 3개를 호출 시, 자바스크립트는 다음과 같이 작업을 할당합니다. 순서대로 함수를 호출하며 한개의 task가 끝날때까지 다음 task는 끼어들 수 없는 블로킹 방식으로 동기가 이루어집니다. \r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/a5298539-fe91-4a59-bd30-0f69822ad327/image.PNG)\r\n\r\n## 동기 처리의 문제점 \r\n![](https://velog.velcdn.com/images/damin1025/post/fb33ffa5-fbc4-42e0-8d4a-966a84597e2c/image.PNG)\r\n\r\n🤔 작업 시간이 긴 task를 처리할때 문제가 발생하게 된다.프론트는 속도가 생명이지 않나…? \r\n\r\n**멀티 스레드**로 방식으로 처리하면 되지 않나요?\r\n⇒ OS 상 생각은 ok. 하지만 자바스크립트는 **Single Thread**로 동작합니다. \r\n\r\n그래서 동기처리 대신 **비동기 처리** 개념이 필요해지게 됩니다.\r\n\r\n## 비동기 처리\r\n![](https://velog.velcdn.com/images/damin1025/post/57548644-48a6-4b56-8277-cb53ddac1f69/image.PNG)\r\n\r\n🤔 논 블로킹 방식이면 작업이 어떻게 끝나고 처리되는지.. 중구난방 아닐까요?\r\n→ **콜백 함수**를 활용합니다. \r\n\r\n대표적인 콜백 함수는 `setTimeout()` 으로, 코드를 바로 실행하지 않고 몇초 기다렸다가 다음 함수를 실행하는 방식으로 순서가 중구난방일지 염려되는 부분을 해결할 수 있습니다. \r\n\r\n```jsx\r\nfunction taskA() {\r\n\tsetTimeout(() => {\r\n\t\tconsole.log('A Task End');\r\n\t}, 2000); // 다음 함수 실행까지 2초 기다려줌 \r\n}\r\n\r\ntaskA();\r\nconsole.log('코드 끝');\r\n```\r\n---\r\n\r\n실행 결과\r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/bd013054-c63e-45d6-aea2-2a94361d7326/image.gif)\r\n\r\n## JS Engine\r\nJS Engine 기본 구성\r\n<br/>\r\n-Heap : 메모리 할당<br/>\r\n-**Call Stack** : 코드 실행\r\n\r\n### Call Stack 동기 작동방식\r\n\r\n항상 Main context가 먼저 stack에 push 됌. 그리고 선언한 함수 순서대로 Call Stack에 push되고, 작업이 끝나면 pop이 이루어짐.\r\n\r\n### 비동기 작동 방식\r\n여기서 `setTimeout()` 은 대표적인 **비동기 함수**인데, 만약 동기처리 방식 그대로 적용한다면 call stack에 3초 머물렀다가 콜백함수 `cb`를 호출하게 되는데 이와 같이 수행한다면 동기 처리 방식과 비동기 처리 방식의 차이점이 사라지게 됩니다.\r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/359c37e2-d6df-4195-af7d-3cf8d7011385/image.PNG)\r\n\r\n따라서 해당 비동기 함수는 비동기 처리를 위해, Web APIs에 3초동안 기다리면서 `asyncAdd()` 함수가 실행되면서 pop되면서 종료되고\r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/18c5b0e0-04d0-4a46-8beb-b5106cdac240/image.PNG)\r\n\r\n\r\n3초 기다린 `setTimeout()`은 제거가 되면서 콜백함수 `cb`를 콜백 큐에 push합니다.\r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/81ed6192-8b10-4789-ace7-ec3b9fc7b30e/image.PNG)\r\n\r\nEvent Loop을 통해 cb함수는 call stack로 push됩니다. \r\n\r\n이때 Event Loop는 Main Context를 제외한 다른 실행할 함수들이 Call stack에 존재하는지 계속해서 check합니다. 만약 수행할 함수가 콜백함수밖에 없다면, 그제서야 콜백함수를 Call Stack에 push하는 방식인거죠. \r\n\r\n그렇게 콜백함수를 수행하고 pop 후, Main Context도 제거되면서 비동기 작업이 완료가 됩니다. \r\n\r\n### 비동기 처리 방식의 문제점\r\n\r\n⇒ 만약 불러야 할 콜백함수를 메소드 내에서 계속 선언하게 된다면 **콜백지옥**을 야기합니다. 이는 이제 ES6+ 문법 중 `Promise` 객체 와 `async()-await()` 로 해결할 수 있습니다."},{"id":"2d63d8d1-10f5-5ee4-8eba-a7a378c5337b","path":"/TIL/Redux-useDispatch/","title":"Redux Toolkit - useDispatch로 state rasie하기","body":"## state를 useDispatch로 보내기 \r\n\r\n이전 포스팅에서 Redux toolkit으로 store를 셋팅을 했다면, 실제로 이제 각 컴포넌트에서 수행할 리듀서 함수를 import하여 사용하는 방법에 대해서 알아보도록 하겠습니다. \r\n\r\n\r\n## 순서\r\n**1. 컴포넌트에 알맞는 리듀서 함수를 import하기**\r\n\r\n해당 포스팅에서 todoList App의 핵심적인 기능인 **할일을 추가** 하는 기능을 수행하는 컴포넌트에 알맞는 리듀서 함수를 import 해보겠습니다. \r\n\r\nreducer slice 에 `addTodo()` 리듀서 함수를 구현했으므로, 해당 함수를 import 해야 할 것입니다. \r\n\r\n```jsx\r\nimport { addTodo } from '../redux/slices/todoSlice';\r\n```\r\n\r\n`slices` 에 리듀서 함수들을 export했기 때문에 import가 가능합니다.\r\n\r\n#### **2. state를 raise하기 하기** \r\n\r\n부모 컴포넌트 store에서 모든 state를 바꾸기 때문에 state를 바꾼다는 전달하는 매개체가 필요합니다. 이 매개체는 `useDispatch()` 훅으로 전달할 수 있습니다. \r\n\r\n```jsx\r\nimport { useDispatch } from 'react-redux';\r\n\r\n// 컴포넌트 내에 작성합니다. \r\nconst dispatch = useDispatch(); \r\n```\r\n`useDispatch()` 를 import합니다. \r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/a1626d25-39a9-448f-a5fb-6a20d073bf99/image.PNG)\r\n\r\n그리고 `dispatch` 함수 내부에 위에서 import한 리듀서 함수를 trigger합니다. 이와 같은 process로 리듀서 함수로 state를 raise할 수 있습니다. "},{"id":"a041e359-fd49-504e-9a3b-28dfdba117e0","path":"/TIL/what-is-CORS/","title":"CORS에 대해서 알아보자","body":"### Origin 이란?\r\n\r\n아래와 같이 사이트들이 있다고 가정해보겠습니다. \r\n\r\n```bash\r\nhttp://localhost:8000\r\nhttps://api.alazierplace.com:3000/api/\r\nhttps://alazierplace.com/2019/05/data-driven-testing-how-we-went-from-150-test-cases-to-1/\r\n```\r\n\r\nscheme(http,https) + IP 주소 또는 도메인 + :포트넘버 ⇒ 해당 구성을 Origin 이라고 칭합니다. \r\n\r\nJS의 Script 파일이 HTTP에 API 요청을 할때, 서버에 요청을 보내기 전에 Origin 정보를 헤더에 저장합니다. \r\n\r\n### CORS 이슈가 중요한 이유\r\n\r\nOrigin이 다른 헤더값을 계속해서 요청하게 되면, 악의적인 스크립트로 인해 보안성이 취약해지고, 유저와 사이트에 해가 될 수 있습니다.\r\n특히 `same-orign policy` 는 클라이언트 쪽에서 더 중요하게 다뤄지는 부분이기 때문에 더욱이 CORS를 따져줘야 합니다. (*`same-origin-policy` : 없는 도메인 값 또는 포트를 요청하는 행위) \r\n\r\n### CORS란?\r\n\r\nCross-Origin Resource Sharing의 약자로, W3C가 제안한 웹 표준으로 클라이언트가 실행되는 브라우저에서 origin값을 접근할 수 있도록 가능케 하는 개념입니다.\r\n\r\n![Request/Response cycle for a CORS Request](https://i0.wp.com/alazierplace.com/wp-content/uploads/2019/06/CORS-flow.png?resize=833%2C406&ssl=1)\r\n\r\nRequest/Response cycle for a CORS Request\r\n\r\n**<실행 순서>**\r\n\r\n- JS 클라이언트가 AJAX call을 시작함\r\n- 브라우저가 (실제 클라이언트가 서버에 요청을 보내기전에) request를 intercept하여 `pre-flight` 요청을 보냄\r\n- 서버는 `pre-flight` 에 대한 response에 CORS configuration을 담은 HTTP 헤더를 브라우저에 보냄\r\n- CORS가 verify되면 실제 클라이언트가 request한 값을 서버에 보내게 됌\r\n- 서버는 요청한 response값을 JS Client에 보내줌\r\n\r\n******************pre-flight request?****************** \r\n\r\n- HTML 옵션을 request 하는 것으로, 이에 대한 response로는 CORS configuration(구성 파일)을 명시하는 HTTP 헤더\r\n- 한번만 보내지고, 브라우저에 의한 캐싱이 처리된다.\r\n- 매번 CORS request가 보내지는건 아니고 다음과 같은 조건에 부합할때 보내진다.\r\n    - `HEAD`, `POST`, `GET` 이외의 HTTP 메소드를 request 할때\r\n    - Content-type request에 application/x-www-form-urlencoded, multipart/form-data 및 text/plain 이외의 값이 있을때\r\n    - 요청이 Accept, Accept-Language 및 Content-Language 이외의 헤더를 설정할때\r\n\r\n### 그래서 왜 이렇게까지 CORS를 따져야 할까?\r\n\r\nJavaScript는 돌아갈 수 있는 실행환경이 다양하기 때문입니다. \r\n\r\n특히 JavaScript 같은 경우는, 네트워크를 통해 브라우저의 형태로 사용자에게 제공됩니다. 그리고 웹뿐만 아니라 모바일 웹에서도 접근이 가능하기 때문에 실행환경 역시 다양해집니다. \r\n\r\n브라우저는 로그인 정보, 쿠키, 세션등 민감한 정보들을 담고 있고 이에 대한 철저한 규제가 필요할 것입니다. \r\n\r\n비유해서 말하면.. 이상한 사람이 맛있는거 사준다고 해도 쫓아가면 안된다 를 표현한 개념이 CORS라고 볼 수 있습니다. JavaScript 클라이언트에서 이에 대한 빡센 규정이 필요하죠."},{"id":"eb7f9757-da97-554a-98d0-a997dbd71b62","path":"/TIL/Redux-Toolkit/","title":"Redux Toolkit으로 React Native Todo앱 구조 잡아보기","body":"## 🔎 동기\r\n리액트 프로젝트를 진행하면서 가장 챌린지 했던 부분은 **state관리**였습니다. \r\n\r\n각각의 컴포넌트는 state를 관리하고 있지만, 컴포넌트 파일이 방대해지고 props로 전달해야 되는 부분이 많아지게 되면 state 관리가 복잡해져서 굉장히 설계에 어려움을 겪었던 경험이 있었습니다.. 😥 \r\n\r\n하지만 Redux는 이러한 부분을 완화시켜줄 수 있는 tool로, store로 모든 state를 관리할 수 있습니다. 따라서 React Native로 진행하고 있는 Todo App의 data state의 관리를 `Redux Toolkit` 을 통해 로직을 구현하고자 합니다.  \r\n\r\n## 🛒 순서\r\n전체적인 구조는 어떠한 이벤트가 발생 시, 해당 Action을 Dispatcher에 전달하여 Reducer 함수들을 통해 해당하는 Action의 state를 raise하여 반환합니다. 그리고 store 내부 state가 update 되면 그 state를 컴포넌트에 전달하여 리렌더링이 진행됩니다. \r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/441bb55f-8efc-4bb3-a07a-6040a8a059a7/image.png)\r\n\r\n\r\n다음 CLI 명령어로 `Redux Toolkit`을 생성할 수 있습니다.\r\n```bash\r\nnpm install @reduxjs/toolkit react-redux\r\n```\r\n\r\n### 1. configureStore를 사용하여 Redux Store 생성\r\n```jsx\r\nimport { configureStore } from \"@reduxjs/toolkit\";\r\nimport todoReducer from './slices/todoSlice';\r\n\r\nexport const store = configureStore({\r\n    reducer:{\r\n        todo: todoReducer //생성한 reducer를 Store에 등록\r\n    }\r\n});\r\n```\r\n\r\n### 2. React 컴포넌트에 Redux Store 제공 순서\r\n제 프로젝트의 `App` 컴포넌트 아래 컴포넌트인 `MainScreen` 컴포넌트에 data 및 state를 공급하기 위해 다음과 같이 `Provider` 컴포넌트에 `store`를 props로 전달해야합니다. \r\n\r\n```jsx\r\nimport { Provider } from 'react-redux';\r\nimport {store} from './redux/store';\r\nimport MainScreen from './screens/MainScreen';\r\n\r\nexport default function App() {\r\n  return (\r\n    <Provider store={store}>\r\n      <MainScreen/>\r\n    </Provider>\r\n  );\r\n}\r\n```\r\n\r\n⚠ 이때 생성한 store는 **내장 모듈이 아니기 때문에** `{ }` 로 감싸서 모듈을 import 하는것에 주의합니다.\r\n  \r\n\r\n### 3. createSlice로 Redux slice reducer 생성\r\n`createSlice`를 활용하여 상태관리 함수 로직을 구현합니다. \r\n제 프로젝트에는 add,update,delete에 관한 상태관리함수가 필요하기 때문에 `reducer`로 정의합니다. \r\n\r\n```jsx\r\nconst todoSlice = createSlice({\r\n  name: \"todo\", \r\n  initialState: {\r\n        currentId: 4,\r\n        todos: [],\r\n    }, //초기 state 정의\r\n  reducers: {\r\n    //state functions(add,delete,update 로직 구현 부)\r\n  },\r\n});\r\nexport default todoSlice.reducer; \r\n```\r\n\r\n### 4. useSelector, useDispatch로 데이터 읽고 state raise하기\r\n\r\n`useSelector`로 `store`에서 데이터를 읽어줍니다.\r\n`useDispatch`로 dispatch함수를 가져오고 필요에 따라 action을 dispatch합니다. (action을 dispatch한다 = event를 trigger한다.)\r\n\r\n해당 부분은 다음 포스팅에서 더 자세히 다루겠습니다.\r\n\r\n## 🌌 리듀서 함수 구체화하기\r\n`createSlice`로 Redux slice Reducer를 생성했다면 각각의 상태관리함수 (add,update,delete)에 대해서 구현을 진행하겠습니다. \r\n\r\n### 1. addTodo()\r\n![](https://velog.velcdn.com/images/damin1025/post/cfab0e3f-ee60-49c1-983f-a88b9cbec230/image.PNG)\r\n\r\n현재 state의 할일 배열값을 받을 `todos`에 값을 push해주는 로직으로 구현할 수 있습니다. \r\n\r\n### 2. updateTodo()\r\n![](https://velog.velcdn.com/images/damin1025/post/8aa630c4-94c4-4ca9-a5e0-4fb4b7f5cc05/image.PNG)\r\n\r\nupdate(할일 종료)했다는 index를 따기 위해서 `item` 변수에 `findIndex()`로 상태가 변화한 index를 담습니다. 그리고 삼항연산자를 통해 todo -> done 으로 state를 바꿔주고, `todos` 배열에서 제거한 값을 배열에 push합니다. \r\n\r\n\r\n### 3. deleteTodo()\r\n![](https://velog.velcdn.com/images/damin1025/post/0bc7ec31-156b-4bff-9360-865913c271e7/image.PNG)\r\n\r\n`x` 버튼을 삭제하는 로직입니다. 전체적인 흐름은 `updateTodo()` 와 동일합니다.\r\n\r\n\r\n### reducer 함수 export 하기 \r\n마지막으로 해당 reducer함수들을 외부 컴포넌트에서도 사용할 수 있도록 export하는 작업으로 마무리합니다.\r\n```jsx\r\nexport const { addTodo, updateTodo, deleteTodo } = todoSlice.actions;\r\n```\r\n"},{"id":"272d2bb7-2ca7-5a97-8444-57d04952b875","path":"/TIL/what-is-gatsby/","title":"Gatsby란?","body":"### Gatsby에 대해 설명하기 전에..\r\n[Gatsby](https://www.gatsbyjs.com/)는 React 기반으로 설계된 프레임워크입니다. 이때 Gatsby를 알기전에 **JAM Stack**이라는 용어에 대해서 알아야 할 필요가 있습니다. \r\n\r\n블로그나 포트폴리오와 같이 **정적 페이지**를 개발해야 할 때에 활용됩니다. 정적 사이트 생성기인 Gatsby를 시작하기 전에 <span style=\"color:red\">JAM Stack</span>에 대해 먼저 알아봅시다. \r\n\r\n\r\n### JAM Stack이란?\r\n\r\nJAM Stack은 더 빠르고, 안전하며, 스케일링하기 쉬운 웹을 만들기 위해 디자인된 아키텍처입니다. \r\n\r\n즉 JAM Stack은 JavaScript, API, MarkUp Stack의 약자로, 자바스크립트와 API, HTML이나 CSS 등을 칭하는 MarkUp으로 이루어진 웹 구성 방법입니다.\r\n\r\n이름에 있는 그대로 저 3가지의 기술을 통해 홈페이지를 만든다는 것인데, 그럼 기존 웹 사이트와는 어떤 차이점이 있을까요?\r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/0b81fb8f-ec23-40fc-bc72-93a1a3a4af89/image.png)\r\n\r\n\r\n기존 웹 사이트의 방식은 대부분 서버에서 데이터베이스 또는 CMS(Content Management System)로부터 추출한 데이터를 프론트엔드에 뿌려주는 방식입니다. 이는 클라이언트에 데이터를 보여주기 위해서 많은 절차를 거쳐야만 하기 때문에 구조가 복잡합니다.\r\n\r\n하지만 JAM Stack을 사용한 방식은 기존 웹사이트의 방식과 다르게 절차가 매우 간단합니다.\r\n\r\n각종 마크업 요소와 다양한 API를 통해 만든 정적 웹사이트를 **Pre-Render**한 것을 CDN(Content Delivery Network)을 통해 웹 사이트를 제공해줍니다. 그렇기 때문에 기존 방식에 비해 **더 빠르게** 웹 사이트를 볼 수 있다는 거죠. \r\n\r\n#### 1. 기존 방식에 비해 더 빠르게 웹 사이트를 제공할 수 있습니다.\r\n구체적으로는 JAM Stack은 렌더링할 화면들을 모두 Pre-Render하여 제공되어 그만큼 사용자에게 화면을 보여주기 위해 준비하는 시간을 단축할 수 있습니다.\r\n\r\n이에 더불어서 브라우저에서 첫 응답을 받기까지 걸리는 시간인 TTFB(Time to First Byte)를 최소화하는 데에는 미리 빌드 된 파일을 CDN을 통해 제공하는 것보다 나은 방법이 없다고 합니다.\r\n\r\n#### 2. 안전한 웹 사이트를 제공할 수 있습니다.\r\n\r\nJAM Stack은 API를 통해 정적 사이트를 생성합니다.\r\n\r\n여기서 사용되는 API는 JAM Stack을 활용한 각 프레임워크에서의 **마이크로 서비스**로서, 사이트 생성을 위한 프로세스가 추상화되어 있기 때문에 그만큼 공격 노출 범위가 감소하게 됩니다.\r\n\r\n따라서 개발자는 웹 개발 중 발생할 수 있는 취약점에 대해 보다 덜 신경쓸 수 있습니다.\r\n\r\n#### 3. 스케일링하기 쉬운 웹 사이트를 제공할 수 있습니다.\r\n\r\n정적 웹사이트에서의 스케일링이란, 더 많은 지역에서 홈페이지를 제공할 수 있게 하는 의미입니다. 미리 빌드 된 파일 제공을 담당하는 CDN이 그 역할을 충분히 수행해낼 수 있습니다.\r\n\r\n\r\n### Gatsby VS Next.js\r\n\r\nGatsby와 함께 항상 언급되는 JAM Stack 기반 프레임워크인 Next.js와 비교를 또 빼놓을 수가 없죠. 둘 모두 React 기반의 프레임워크입니다.\r\n\r\n그럼 이쯤에서 한번쯤은 모두 고민을 할 것입니다. \r\n\r\n>🤷🏼‍♀️ Next.js가 대세라는데? 현재 1등을 달리고 있는 프레임워크라는데.. \r\n\r\n항상 프론트엔드 개발을 수행하면서 딜레마인 부분인것 같습니다. 트렌드를 쫓는다는것..하지만 각 프레임워크마다 모두 장단점이 있고, 목적에 맞게 잘 활용하는것이 중요하다고 생각합니다.\r\n\r\nGatsby와 Next.js 역시 두 프레임워크의 사용 용도가 다릅니다.\r\n\r\n`Next.js`는 정적 사이트 생성의 기능도 있지만 주로 **SSR**을 위해 사용하는 프레임워크입니다. 하지만 `Gatsby`는 **서버 없이**, 오로지 정적 사이트 생성를 위해 사용하는 프레임워크입니다.\r\n\r\n그래서 `Next.js`는 주로 기업단위의 대규모 프로젝트에 활용이 되고, `Gatsby`는 개인 포트폴리오나 기술 블로그 개발에 활용이 됩니다. (저는 저만의 기술 블로그를 만들 예정이기에 `Gatsby`를 활용할것입니다.)\r\n\r\n"},{"id":"d778771d-6091-5bd9-a7c1-c0cca0fc513e","path":"/TIL/자바스크립트-비동기함수/","title":"Promise 객체, async-await 함수를 활용한 비동기 처리","body":"## Promise 객체\r\n\r\n동기: 콜백 지옥에서 탈출하기\r\n\r\n**비동기 작업이 가질 수 있는 3가지 상태**\r\n\r\n![https://joshua1988.github.io/images/posts/web/javascript/promise.svg](https://joshua1988.github.io/images/posts/web/javascript/promise.svg)\r\n- Pending: 대기상태 (성공 or 실패)\r\n- Fulfilled: 성공 (Pending 상태에서 resolve 됐다)\r\n- Rejected: 실패 (Pending 상태에서 rejecet 됐다)\r\n\r\n\r\n#### Promise 객체를 활용한 비동기 구문\r\n```jsx\r\n// 기존 비동기 처리 \r\nfunction isPositive(number,resolve,reject) {\r\n\tsetTimeout(()=> {\r\n\t\tif(typeof number === 'number') {\r\n\t\t\t//resolve\r\n\t\t\tresolve(number >=0 ? \"양수\" : \"음수\");\r\n\t\t} else {\r\n\t\t\treject(\"주어진 값이 숫자형이 아닙니다\");\r\n\t\t},2000);\r\n}\r\n\r\n// Promise 객체를 반환하여 구현한 비동기 코드\r\nfunction isPositiveP(number) {\r\n\t//실행자 \r\n\treturn new Promise(resolve,reject) => {\r\n\t\tsetTimeout(()=> {\r\n\t\t\tif(typeof number === 'number') {\r\n\t\t\t\tresolve(number >=0 ? \"양수\" : \"음수\");\r\n\t\t\t} else {\r\n\t\t\t\treject(\"주어진 값이 숫자형이 아닙니다\");\r\n\t\t\t},2000);\r\n\t};\r\n}\r\n\r\nconst res = isPostiveP(101); //101\r\n\r\nres\r\n\t.then((res) => { \r\n\t\tconsole.log(\"작업 성공: \",res);\r\n\t}).catch((err)=>{\r\n\t\t\tconsole.log(\"작업에러\")\r\n\t}); \r\n```\r\n\r\n`then` 과 `catch` 구문을 활용하여 Fulfilled 상태인지 Rejected 상태인지 처리 결과값을 반환 받을 수 있습니다. \r\n\r\n\r\n\r\n## 여러 개의 프로미스 연결하기 (Promise Chaining)\r\n\r\n프로미스의 또 다른 특징은 **여러 개의 프로미스를 연결**하여 사용할 수 있다는 점입니다. 앞 예제에서 `then()` 메서드를 호출하고 나면 새로운 프로미스 객체가 반환됩니다. \r\n\r\n```jsx\r\nfunction getData() {\r\n  return new Promise({\r\n    // ...\r\n  });\r\n}\r\n\r\n// then() 으로 여러 개의 프로미스를 연결한 형식\r\ngetData()\r\n  .then(function(data) {\r\n    // ...\r\n  })\r\n  .then(function() {\r\n    // ...\r\n  })\r\n  .then(function() {\r\n    // ...\r\n  });\r\n```\r\n\r\n## async- await : 직관적인 비동기 처리 코드 작성\r\n```jsx\r\n// async 예제\r\nasync function helloAsync() {\r\n\treturn 'hello async';\r\n} \r\n```\r\n\r\n`helloAsync()` 함수 콘솔을 찍으면 **Promise 객체**를 반환하는데 이는 `async` 함수의 특징 중, Promise 객체를 반환하는 특징 때문입니다.\r\n\r\n이때 다음 코드를 출력해보면 ‘hello async’가 정상적으로 콘솔에 출력됩니다. 이는 `res` 콜백함수가 `helloAsync`함수의 return을 바라봤다고 볼 수 있습니다. \r\n```jsx\r\nhelloAsync.then((res) => {\r\n\tconsole.log(res);\r\n});\r\n```\r\n\r\n```jsx\r\n// await 예제\r\nfunction delay(ms) {\r\n\treturn new Promise(resolve) => {\r\n\t\tsetTimeout((resolve,ms);\r\n\t});\r\n}\r\n\r\nasync function helloAsync() {\r\n\treturn delay(3000).then(()=> {\r\n\t\treturn 'hello async';\r\n\t});\r\n} \r\n```\r\n\r\n위 함수를 **async-await 구문**으로 리팩토링하면 아래와 같습니다.\r\n```jsx\r\nasync function helloAsync() {\r\n\tawait delay(3000);\r\n\treturn 'hello async';\r\n} \r\n\r\nasync function main() {\r\n\tconst res = await helloAsync();\r\n\tconsole.log(res);\r\n} \r\nmain(); // 3초 기다렸다가 'hello async' 반환\r\n```\r\n\r\n이때 `await` 함수는 동기적으로 수행되기 때문에, await에 선언된 구문을 먼저 수행을 해야 return할 수 있는 구조이다. \r\n\r\n#### async-await 구문 정리\r\n```jsx\r\nasync function 함수명() {\r\n  await 비동기_처리_메서드_명();\r\n}\r\n```\r\n\r\n## API 호출\r\nAPI : 클라이언트와 서버간 통신할 수 있도록 도와줌 (request and response)\r\n\r\n\r\n\r\n```jsx\r\n// <JSON placeholder를 활용한 API 호출 메소드 예제>\r\nlet response = fetch('Json Placeholder URL...').then((res) => \r\n\tconsole.log(res)\r\n);\r\n```\r\n\r\n이때 `fetch()` 함수에 hover시, `Promise<Response>` 로 Promise 객체를 반환함을 알 수 있습니다. 즉 `fetch()` 함수는 **비동기 함수** 임을 의미하고, `then` 키워드도 작성할 수 있습니다.\r\n\r\n이를 이제 async-await 함수를 통해 리팩토링 시, 다음과 같습니다.\r\n\r\n```jsx\r\nasync functiong getData() {\r\n\tlet rawResponse = await fetch('Json URL');\r\n\tlet jsonResponse = await rawResponse.json();\r\n\tconsole.log(jsonResponse);\r\n}\r\ngetData(); // 객체 배열 반환 \r\n```"},{"id":"5ca741cd-55d3-5b76-82fd-a6b5ff84ea06","path":"/Develop/ChartJS-그래프-초기화-destroy/","title":"chart.js 그래프 초기화 - destroy()","body":"## Issue - \"Canvas is already in use\"\r\n웹팩 번들링 문제를 해결하고 나니, 또 다른 이슈가 발생했었다. ~~산 넘어 산~~\r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/3ad00259-a0dc-4322-a127-1233bc165b1b/image.PNG)\r\n\r\n구글링 해보니, 꽤 유명한 에러 로그인것 같았다.\r\n\r\n초기에 그래프를 로딩하고 그리는데에는 문제가 없었지만, 다른 나라를 클릭하고 데이터를 불러올때, 기존 그래프가 **초기화** 되질 않아서 다음과 같이 이슈가 발생했다. 6일동안 삽질한 결과 다음과 같이 해결할 수 있었다.\r\n\r\n### 해결\r\n[chart.js 공식문서](https://www.chartjs.org/docs/latest/developers/api.html) 에서는 기존 차트 instance를 날리고 싶으면 `.destroy()` 메소드를 써보라고 합니다. \r\n\r\n>This must be called before the canvas is reused for a new chart.\r\n\r\n네 console에 잡혔던 에러랑 똑같은 말을 해주고 있죠,, 이걸로 쇼부를 봅시다.\r\n\r\n### 코드\r\n```tsx\r\nimport Chart from chart.js/auto\r\n\r\nfunction renderChart(data: number[], labels: string[]) {\r\n  const lineChart = $('#lineChart') as HTMLCanvasElement;\r\n  const ctx = lineChart.getContext('2d');\r\n  if (Chart.getChart(lineChart)) {\r\n    Chart.getChart(lineChart)?.destroy();\r\n  }\r\n\r\n  Chart.defaults.color = '#f5eaea';\r\n  Chart.defaults.font.family = 'Exo 2';\r\n  if (!ctx) {\r\n    return;\r\n  }\r\n  new Chart(ctx, {\r\n    type: 'line',\r\n    data: {\r\n      labels,\r\n      datasets: [\r\n        {\r\n          label: 'Confirmed for the last two weeks',\r\n          backgroundColor: '#feb72b',\r\n          borderColor: '#feb72b',\r\n          data,\r\n        },\r\n      ],\r\n    },\r\n    options: {\r\n      maintainAspectRatio: false, //차트 그래프 사이즈 고정\r\n    },\r\n  });\r\n}\r\n```\r\n해당 코드에서 3번째 line의 if문을 주목하시면,\r\n1. `Chart.getChart(lineChart)`가 만약 값이 할당되어 있다면 (=그래프가 그려져 있음)\r\n2. 그 차트값을 불러오고, `destroy()` (=그래프 초기화) \r\n\r\n를 의미합니다. 따라서 다음과 같이 코드를 수정 시, 그래프가 동적으로 변하지 않는 이슈가 해결됩니다. \r\n\r\n### +) 타입 강하게 잡아내기 : 옵셔널 체이닝(연산자 : ?)\r\n이때 `Chart.getChart(lineChart)?.destroy();` 이게 뭔가 싶으실텐데요\r\n해당 연산자는 **Optional Chaining** 이라고 다음 코드와 동일한 의미를 갖습니다.  \r\n\r\n```js\r\nif (Chart.getChart(lineChart) === null \r\n    || Chart.getChart(lineChart) === undefined) { \r\n  return; \r\n}\r\nelse { \r\n  Chart.getChart(lineChart).destroy(); \r\n}\r\n```\r\n`Chart.getChart(lineChart)` 가 `null` 또는 `undefined`에 해당하지 않는다면(=그래프가 이미 그려져 있는 상태) `destroy()` 하라는것과 동일한 의미를 지닙니다. "},{"id":"25d7e1ed-5544-5429-bfea-818f06c9799d","path":"/Develop/Gatsby-Search/","title":"Gatsby 블로그 - 검색기능 구현하기🔎","body":"## 동기\r\n동기라고 거창하게 써놨지만 별거 없습니다. 앞으로 이 블로그를 평생 쓸 예정인데.. 그럼 지금보다 포스팅 수도 더 많아질거고. 그러면 내가 일일이 무한 스크롤로 내려서 글을 찾는 행위 자체가 굉장히 불편한데? \r\n\r\n정말 이 사고의 흐름대로 생각했고 이 고민에 대한 결론은 \"그래. 검색 기능을 만들어보자!\" 로 귀결됐습니다. \r\n\r\n\r\n## 결과 화면\r\n![](https://velog.velcdn.com/images/damin1025/post/515c2fd7-c31e-4497-81c5-65f39ba31a30/image.gif)\r\n결과 화면은 위와 같이 검색 아이콘을 클릭 후 검색 페이지로 이동하여 keyword를 검색하면 아래에 관련 포스팅이 나열되고 그리고 원하는 포스팅으로 이동하는 방식으로 구현에 진행했습니다. \r\n\r\n\r\n## 어떤 기술을 선택할 것인가\r\n[공식 docs](https://www.gatsbyjs.com/docs/how-to/adding-common-features/adding-search/)를 보면 gatsby에 검색을 구현하는 방법을 크게 2가지로 소개하고 있습니다.\r\n\r\n첫 번째 방법은 **클라이언트 측 검색**입니다. 빌드 또는 런타임에 데이터를 인덱싱하고 이를 이용해 로컬에서 검색을 수행하는 방법입니다. 공식 docs에서는 `js-search`, `gatsby-plugin-elasticlunr-search`, `gatsby-plugin-local-search` 를 제시하고 있습니다.\r\n\r\n두 번째 방법은 **API기반 검색엔진**을 활용하는 방법으로 외부 서비스를 활용하는 방식입니다. 빌드 시점에 검색 대상 데이터들을 인덱싱해 외부 서비스에 올려두고 런타임에는 API로 검색합니다.\r\n\r\n하지만 API기반 검색엔진 사용 시 블로그의 빌드 배포 프로세스에 인덱스를 전송해야하고 사용 시 비용이 발생하거나 그리고 무료인 경우 횟수에 제약이 있어 굳이 사용해야 할 이유는 찾지 못했고, 클라이언트 측 검색 방법이 블로그에 부담이 덜 갈것 같은 방식이라고 생각하여 저는 첫번째 방법으로 아이디어를 scheme했습니다.\r\n\r\n## 검색 관련 라이브러리 \r\n여러 Gatsby Starter에 구현된 검색 기능을 참고해봤을때, GraphQL에서 요청한 edges를 모두 돌아 값을 불러오고, 그리고 그 값을 돌면서 search하는 방식으로 구현된 방식이 많았습니다. 하지만 search 시, 모든 배열의 사이즈에 depend하기 때문에 `O(N) time`이 소요되는 것을 생각하면 추후 포스팅 양이 많아지게 될때 검색 속도 저하를 야기할 수 있습니다. 따라서 검색 라이브러리를 활용하는 것이 시간 복잡도면에서 나을것 같다는 판단이 들었습니다. \r\n\r\n검색 라이브러리로 구현 시, 아래와 같은 기능을 제공합니다. \r\n\r\n- 인덱싱으로 빠른 검색\r\n- 검색하려는 콘텐츠(제목 혹은 본문)에 더 가중치를 둘 수 있다\r\n- 검색어 하이라이팅 기능\r\n- 검색에 and, or과 같은 논리 연산 적용 가능\r\n\r\n그럼 어떤 라이브러리로 이를 실현할 수 있을까 고민을 하던 중에 [해당 블로그](https://velog.io/@seyoung8239/Gatsby-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B2%80%EC%83%89%EA%B8%B0%EB%8A%A5-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0)에서 아이디어를 얻어갈 수 있었습니다.\r\n\r\n`flexsearch` 나 `lunr` 같은 경우는 한글 검색어 이슈가 있고(영문에 특화) `js-search`는 그 생태계가 아직 좁았기에 `fuse.js` 방식을 선택했습니다. \r\n\r\n## fuse.js 검색 \r\n[fuse.js](https://fusejs.io/)는 fuzzy하게 search한다에서 착안됐습니다. 여기서 fuzzy란 **대략적으로 검색**한다의 의미를 지니고 있습니다. \r\n\r\n가장 큰 장점은 백엔드의 지원이 필요 없고, 다른 라이브러리에 dependency를 갖고 있지 않으며 결정적으로 **클라이언트 측 검색**기반이라는 것이었습니다. \r\n\r\n### Gatsby에서 fuse.js 사용하기\r\nGatsby 빌드 과정에서 목록을 인덱싱하여 어딘가 저장해두어야 하고 이렇게 생성된 데이터는 블로그의 런타임에 fuse.js 인스턴스를 생성하여 사용하도록 구성해야 합니다.\r\n\r\n이때 빌드 과정은 플러그인을 활용하면 되고 런타임 검색은 hook을 활용하면 됩니다.\r\n\r\n### gatsby-plugin-fusejs\r\n[gatsby-plugin-fusejs](gatsby-plugin-fusejs) 해당 docs의 npm 명령어를 follow하여 설치를 진행 후, config를 설정합니다. \r\n\r\n```js\r\n// gatsby-config.js\r\n\t{\r\n      resolve: `gatsby-plugin-fusejs`,\r\n      options: {\r\n        // 인덱스를 만들고자 하는 데이터의 쿼리\r\n        query: `\r\n          {\r\n            allMarkdownRemark {\r\n              nodes {\r\n                id\r\n                rawMarkdownBody\r\n                fields {\r\n                  slug\r\n                }\r\n                frontmatter {\r\n                  title\r\n                }\r\n              }\r\n            }\r\n          }\r\n        `,\r\n        // 인덱스를 만들고자 하는 데이터의 프로퍼티\r\n        keys: ['title', 'body'],\r\n        // graphql의 결과물을 단순 객체 배열로 변환하는 함수\r\n        normalizer: ({ data }) =>\r\n          data.allMarkdownRemark.nodes.map((node) => ({\r\n            id: node.id,\r\n            path: node.fields.slug,\r\n            title: node.frontmatter.title,\r\n            body: node.rawMarkdownBody,\r\n          })),\r\n      },\r\n    },\r\n```\r\n설치 후 gatsby-config.js에 인덱스로 만들어지기 원하는 데이터의 쿼리, 데이터 중에서도 검색이 되었으면 하는 프로퍼티, GraphQL 결과물을 객체 배열로 변환하기 위한 함수를 옵션으로 전달합니다. \r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/4ad55151-b71b-474f-bb50-aea87c69e6d3/image.PNG)\r\n\r\nGraphQL 사이트에 접속 시, `allFusejs` 필드가 추가 됨을 확인할 수 있습니다.\r\n\r\n### react-use-fusejs\r\n다음으론 만들어진 인덱스를 활용하기 위해 런타임에 hook을 활용하여 검색을 수행해야 합니다. \r\n\r\n이때 매번 검색어를 입력 시, 인덱스를 parsing 후 인스턴스를 생성하게 되면 추후 포스팅의 양이 많아질때 자원이 낭비됩니다. (Props Drilling) \r\n따라서 이를 방지하기 위해서 index 페이지를 처음 Search 페이지를 클릭 했을때 모두 다운받고 그리고 그 다운받은 data들을 context에 담아 재사용할 수 있도록 유도하는 것이 더 효율적일것입니다. \r\n\r\n```tsx\r\n/* Search.tsx */\r\n\r\n  // index.js(최상위)로부터 다운 후 파싱하여 검색을 수행\r\n  const data = useStaticQuery<SearchProps>(graphql`\r\n    {\r\n      fusejs {\r\n        publicUrl\r\n      }\r\n    }\r\n  `)\r\n\r\n  /**\r\n   * 1. Get User Search Input value\r\n   * 2. Collect all Index data and store in context\r\n   * 3. Based on fuseData find query data with fuzzy search\r\n   * 4. Lazy Loading (when Post's amount is getting larger)\r\n   */\r\n  const [query, setQuery] = useState<string>('')\r\n  const { fuseData, setFuseData } = useContext(AppContext)\r\n  const result = useGatsbyPluginFusejs<SearchItem>(query, fuseData)\r\n  const [isFetching, setIsFetching] = useState(false)\r\n\r\n  const fetching = useRef(false)\r\n  useEffect(() => {\r\n    if (!fetching.current && !fuseData && query) {\r\n      fetching.current = true\r\n\r\n      fetch(data.fusejs.publicUrl)\r\n        .then(res => res.json())\r\n        .then(data => setFuseData(data))\r\n        .finally(() => setIsFetching(false))\r\n    }\r\n  }, [fuseData, query, setFuseData])\r\n```\r\n\r\n인덱스를 재사용하기 위해서 context에 담을 것이고, 이는 최상위 컴포넌트에서 구현해줘야 합니다. 따라서 `context` 폴더를 새로 생성하고, `app.tsx` 파일을 새로 만들어서 아래와 같이 context를 App ➡ Search로 data를 위임할 수 있도록 합니다. \r\n\r\n```tsx\r\n/* app.tsx */\r\n\r\nimport React, {\r\n  createContext,\r\n  SetStateAction,\r\n  useState,\r\n  ReactNode,\r\n  FunctionComponent,\r\n} from 'react'\r\nimport { Dispatch } from 'react'\r\n\r\ninterface AppContext {\r\n  fuseData: any\r\n  setFuseData: Dispatch<SetStateAction<any>>\r\n}\r\n\r\nexport const AppContext = createContext<AppContext>({\r\n  fuseData: null,\r\n  setFuseData: () => {},\r\n})\r\n\r\ntype AppProps = {\r\n  children: ReactNode\r\n}\r\n\r\n// Provide Props to Search\r\nconst AppProvider: FunctionComponent<AppProps> = function ({ children }) {\r\n  const [fuseData, setFuseData] = useState(null)\r\n\r\n  return (\r\n    <AppContext.Provider value={{ fuseData, setFuseData }}>\r\n      {children}\r\n    </AppContext.Provider>\r\n  )\r\n}\r\n\r\nexport default AppProvider\r\n```\r\n이때 Provider에 value를 담을때 객체로 한번 더 감싸서 보내주는 이유는 data의(state) 값이 변경될때 setFuseData는 재생성되지 않지만, fuseData가 재생성되지 않도록 하기 위해 감싸서 보냅니다. \r\n\r\n```js\r\n// gatsby-browser.js\r\nimport { AppProvider } from './src/context/app'\r\n \r\nexport const wrapRootElement = ({ element }) => {\r\n  return <AppProvider>{element}</AppProvider>\r\n}\r\n```\r\n\r\n위와 같이 코드를 모두 구성 시, React-Developer-Tools를 확인하면 Context에 post 정보들이 담겨있는것을 확인할 수 있습니다. 그렇기 때문에 검색어를 입력 시, 해당 값들은 이미 담겨있어 자원의 낭비를 최소화 할 수 있습니다. \r\n![](https://velog.velcdn.com/images/damin1025/post/3258df66-245c-4b99-84aa-6f0d09f7371e/image.PNG)\r\n\r\n\r\n## 배포 후 성능 check\r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/56f43f3a-a80b-42e2-8091-35326e624444/image.PNG)\r\n\r\n검색 기능 추가 후, lightHouse 점수를 확인해본 결과 퍼포에서 1점 깎인것 빼곤 모두 100을 유지했다..!! \r\n"},{"id":"d12c5bee-3eb8-5140-bf4d-d21a9a77880c","path":"/Develop/Gastby-이전글-다음글-구현/","title":"Gatsby 블로그 - 이전글/다음글 버튼 로직 구현하기 ","body":"## 동기 \r\n요즘 `Gatsby`를 활용하여 Tech Blog를 구현하고 있습니다. 얼추 포스팅 템플릿도 구현이 된 상태에서, 다른 사람들이 만든 블로그와 특히 개발 블로그로 유명한 **velog**에서 어떤 요소들을 갖고 있는지 체크해본 결과, \r\n\r\n- TOC (Table Of Contents) 기능 \r\n- 이전글/다음글 기능 \r\n- 댓글 기능 \r\n- ScrollToTop 버튼 기능 \r\n\r\n이 정도로 추려 볼 수 있을것 같습니다. 그래서 저도 최소한 저 기능들은 탑재한 블로그를 제작해야지 생각했습니다. 댓글 기능(Utterance 활용)이나 ScrollToTop 기능은 구글링하면 코드 예제도 많아서 금방 구현할 수 있었습니다. \r\n\r\n제가 이 블로그를 쓰는 이유는 **이전글/다음글** 기능 제작기를 해당 포스팅을 통해서 나열하고자 합니다.. (왜냐하면 3일동안 삽질했기에)\r\n그리고 결정적인 동기는 단순히 사람들이 이 기능을 많이 개발해서 나도 해야지 보단 제 블로그의 작동 구조에 대해서 생각했습니다.\r\n\r\n>👀 시나리오 \r\n>1. 블로그를 읽는다.\r\n>2. 이전글이나 다음글을 보고 싶은데?\r\n>3. ScrollToTop 버튼을 누르고 `<-` 버튼을 눌러 홈화면으로 돌아온다\r\n\r\n사용자 경험이 떨어질것 같은 시나리오라고 생각했습니다. 따라서 **이전글/다음글** 기능을 구현해서 사용자가 다른 포스팅도 쉽게 접근할 수 있도록 해야겠다! 라는 생각에서 시작했습니다. \r\n\r\n## 결과\r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/577bc8c0-a684-4373-9bb8-700597f2a817/image.gif)\r\n\r\n우선 결과부터 보여드리겠습니다. 동작 방식은 위와 같고, 만약 가장 최신 포스트이거나 아니면 가장 오래된 포스트라면 다음글/이전글 버튼이 비활성화 될 수 있도록 로직을 설계했습니다. \r\n\r\n## gatsby-node.js 파일 수정 \r\n\r\n마크다운 파일을 페이지로 변환해주는 `createPages` 에서 비동기적으로 query를 요청하는 부분입니다. 해당 부분에서는, `contents` 폴더 (이 부분은 `gatsby-config.js`에서 options을 설정해줬을거라고 생각하고 설명은 생략하겠습니다.) 에 담긴 마크다운 파일들을 모두 요청합니다. \r\n\r\n```jsx\r\nexports.createPages = async ({ actions, graphql, reporter }) => {\r\n  const { createPage } = actions;\r\n\r\n  // Get All Markdown File For create Pages\r\n  const queryAllMarkdownData = await graphql(\r\n    `\r\n      {\r\n        allMarkdownRemark(\r\n          sort: {\r\n            order: DESC\r\n            fields: [frontmatter___date, frontmatter___title]\r\n          }\r\n        ) {\r\n          edges {\r\n            node {\r\n              fields {\r\n                slug\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    `,\r\n  );\r\n  // ...\r\n}\r\n```\r\n반드시 `graphiql` 에서 해당 쿼리가 정상적으로 출력되는지 확인합니다. (slug가 알맞게 나오는지가 중요) \r\n\r\n\r\n```jsx\r\n  // Import Post Template Component\r\n  const PostTemplateComponent = path.resolve(\r\n    __dirname,\r\n    'src/templates/post_template.tsx',\r\n  );\r\n\r\n  const posts = queryAllMarkdownData.data.allMarkdownRemark.edges\r\n  posts.forEach((\r\n    {\r\n      node: {\r\n        fields: { slug },\r\n      }\r\n    },\r\n    index\r\n  ) => {\r\n    // Logic of Prev/Next Button \r\n    const prev = index === 0 ? null : posts[index-1]\r\n    const next = index === posts.length -1 ? null: posts[index+1]\r\n    createPage({\r\n      path: slug,\r\n      component: PostTemplateComponent,\r\n      context: {\r\n        slug,\r\n        prev,\r\n        next,\r\n      }\r\n    })\r\n  })\r\n```\r\n`posts` 배열을 돌면서, 아까 위에서 언급한 로직을 `prev`, `next`에 작성합니다. 만약 가장 최신글이거나, 가장 오래된 글이면 slug는 <span style=\"color:red\">null</span>로 세팅될것입니다. 그리고  `createPage`에 context에 `prev`, `next`를 추가합니다. \r\n\r\n\r\n## 이전글/다음글 컴포넌트 설계하기 \r\n이제 이전글/다음글 버튼 컴포넌트를 만듭시다. 뭐 디자인적인 부분은 본인이 원하는대로 Styling에 진행하면 될 것 같습니다. \r\n\r\n공통적인 부분이라면, `Props`를 부모 컴포넌트(`post_template`-블로그 포스팅 템플릿)에서 받아오는 부분일것 같습니다. 우리는 slug를 활용해서 접근할 것이고, slug는 string 타입입니다. 따라서 Props로는 `이전글 slug`와 `다음글 slug`를 받아오면 될 것 같습니다. \r\n\r\n```tsx\r\nexport type PrevNextProps = {\r\n  previousPagePath: string | null\r\n  nextPagePath: string | null\r\n}\r\n\r\nconst PostPrevNextBtn: FunctionComponent<PrevNextProps> = function ({\r\n  previousPagePath,\r\n  nextPagePath,\r\n}) {\r\n  return (\r\n    <StyledPager>\r\n      <ul>\r\n        <li>\r\n          {previousPagePath !== null ? (\r\n            <Link to={previousPagePath}>\r\n              <Left /> 다음글\r\n            </Link>\r\n          ) : (\r\n            <span>\r\n              <Left /> 다음글\r\n            </span>\r\n          )}\r\n        </li>\r\n\r\n        <li>\r\n          {nextPagePath !== null ? (\r\n            <Link to={nextPagePath}>\r\n              이전글 <Right />\r\n            </Link>\r\n          ) : (\r\n            <span>\r\n              이전글 <Right />\r\n            </span>\r\n          )}\r\n        </li>\r\n      </ul>\r\n    </StyledPager>\r\n  )\r\n}\r\n\r\nexport default PostPrevNextBtn\r\n```\r\n\r\n## post_template 에서 slug 조작하기 \r\npost_template은 엄밀히 따지면 위에서 설계한 컴포넌트에 Props를 뿌려줘야할 부모 컴포넌트에 해당합니다. 우리는 해당 템플릿에서 `gatsby-node.js` 에서 query로 요청한 값들을 이제 받아와야 합니다. 우선 Props로 그 부분에 대한 타입을 명시합니다. \r\n\r\n```tsx\r\ntype PostTemplateProps = {\r\n  // ...\r\n  pageContext: {\r\n    prev: {\r\n      node: {\r\n        fields: {\r\n          slug: string\r\n        }\r\n      }\r\n    }\r\n    next: {\r\n      node: {\r\n        fields: {\r\n          slug: string\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n그리고 pageContext가 잘 받아와지는지 `console.log(pageContext)`를 수행해보세요. `next,prev,slug`가 object형태로 출력이 된다면 정상적으로 query요청값을 받아왔습니다. \r\n\r\n```tsx\r\nconst PostTemplate: FunctionComponent<PostTemplateProps> = function ({\r\n  //...\r\n  pageContext: { prev, next },\r\n}) {\r\n  return (\r\n    //...\r\n      <PostPrevNextBtn\r\n        previousPagePath={prev ? prev.node.fields.slug : null}\r\n        nextPagePath={next ? next.node.fields.slug : null}\r\n      />\r\n    //...\r\n  )\r\n}\r\n```\r\n잘 받아온 `next`와 `prev`의 object값을 parsing한 slug값을, `PostPrevNextBtn` 컴포넌트에 Props로 넘겨줍니다. \r\n\r\n이때 가장 최신글이나,가장 오래된 글에 대해서는 pageContext console을 찍어보면 `prev,next` object이 **key값으로도 등장하지 않습니다.** 이에 대한 validation check가 필요하기 때문에 위와 같이 삼항연산자를 통해 걸러줍니다. \r\n\r\n\r\n## 맺음말\r\n잘 작동하나요? 저도 여러번의 삽질을 통해서 구현한거라 모두에게 상용될 방법은 아니라고 생각합니다 ㅎㅎ.. 제가 구현한 로직도 역시 참고용으로 본인 코드에 필요한 부분만 떼어가서 살을 붙히시면 될 것 같습니다.🤗 \r\n"},{"id":"2a70bfc3-a825-5826-86cb-e88209ae7d25","path":"/Develop/Gatsby-TOC-구현하기/","title":"Gatsby 블로그 - TOC 기능 구현하기","body":"\r\n🤠 글이 꽤 깁니다! \r\n## 💭 동기 \r\n\r\n포스팅을 읽다 보면, 다시 읽고 싶은 부분으로 돌아가고 싶었던 경험이 있을 겁니다. 이때 일일이 스크롤 해서 내가 원하는 콘텐츠를 읽는 것은 사용자 경험이 굉장히 떨어지는 행위입니다.\r\n\r\n따라서 많은 개발 블로그에는 **TOC**, 즉 Table Of Contents를 제공합니다. 저 역시 제 블로그에 방문해 주시는 유저분들께 편리함을 제공하고자 TOC 기능을 제작하고 구현에 진행했습니다.\r\n\r\nVelog나 다른 개발 블로그들에서 봤을 땐 복잡할 거라고 생각은 안 했는데, 역시 만만한 건 아무것도 없었습니다😅 \r\n\r\n## 결과 \r\n\r\n먼저 구현 결과부터 보여드리겠습니다. \r\n\r\n스크롤 시, 일정 위치에 heading이 scope 시 오른쪽에 있는 TOC의 각각의 요소들에 active 값이 활성화됨을 볼 수 있습니다.\r\n![](https://velog.velcdn.com/images/damin1025/post/021cd97b-05b8-470c-8d95-1c82fe32e9e7/image.gif)\r\n\r\n그리고 각 콘텐츠를 클릭 시, 알맞는 heading으로 direct 하게 이동합니다.\r\n![](https://velog.velcdn.com/images/damin1025/post/ed65ab46-8384-4b63-8db1-f060334ae8a5/image.gif)\r\n\r\n그럼 제가 어떤 flow로 TOC 기능을 개발했는지 회고하고자 합니다. \r\n\r\n## header를 어떻게 갖고 올것인가?\r\n우선 TOC 기능을 구현하는 데 있어, 가장 중요한 것은 포스팅에 있는 header를 어떻게 갖고 올 것인가입니다. 당연하게도 `gatsby-node.js`에서 GraphQL로 요청해야 하는데, 이때 어떤 필드를 참조할 것인가를 생각해 봐야 합니다.\r\n\r\n1) `tableOfContents` 필드를 활용하기\r\n`tableOfContents` 필드를 GraphQL로 요청하여 `dangerouslySetInnerHTML`에 __html 요소로 Props를 보내서 렌더링 하는 방법이 있습니다.\r\n![](https://velog.velcdn.com/images/damin1025/post/dde204d0-a5ed-41f9-808e-dc0ab46cfef6/image.PNG)\r\n\r\n\r\n2) `headings` 필드의 depth와 value를 활용하기 \r\n![](https://velog.velcdn.com/images/damin1025/post/eacbf940-6312-4203-8750-93f29f440712/image.PNG)\r\n\r\n여기서 depth는 h1, h2,...에서 숫자에 해당하는 부분이고, value는 제목입니다. 저는 직접 depth를 handle 하여 CSS도 Styling 할 것이고, 그리고 배열을 돌면서 value를 TOC 컴포넌트에 렌더링 하고 싶었기 때문에 1번보단 2번 방법을 택했습니다. \r\n\r\n## Value를 어떻게 slug화 할것인가?\r\n보통 `tableOfContents` 필드를 활용해서 구현한다면 slug를 자체적으로 알아서 만들어서 `href`로 접근할 수 있도록 값이 부여되는데, 저같은 경우는 `headings`를 활용하기 때문에 **제목을 어떻게 slug 화할 것인가**를 고민해 봤어야 했습니다.\r\n\r\n정말 npm은 없는게 없군요.. [github-slugger](https://www.npmjs.com/package/github-slugger) 라는 패키지를 통해서 slug에 대한 고민을 해결할 수 있었습니다. 해당 패키지를 npm으로 설치하고, `slug(value)` 메서드만 선언하면 알아서 value(제목)를 slug화 해주는 아주 친절한 패키지를 활용하여 해당 고민을 해결할 수 있었습니다.  \r\n\r\n## Data 흐름은? \r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/6f0fe709-8358-4507-aba0-ca1bc62cb64a/image.PNG)\r\n\r\n데이터 흐름은 위와 같이 `post_template.tsx` (포스팅 템플릿)에서 GraphQL로 요청한 headings(depth,value)를 `PostTOC.tsx` 에 전달하는 구조로 설계하고 구현에 진행했습니다. \r\n\r\n## TOC 컴포넌트 Styling \r\n\r\n자 그럼 GraphQL로 요청한 headings들을 이쁘게 Render하기 위해  Styling 작업을 해야 합니다. \r\n\r\n사실 TOC 기능을 만들면서 꽤 시간을 많이 들였던 부분이 바로 이 Styling 부분이기도 했습니다. CSS적으로 deep하게 MockUp 했고.. 따라서 이건 본인이 스스로 고민하면서 만드는 것을 추천드립니다. 제 코드를 봐도 본인 프로젝트에서는 또 적용이 안될수도 있기 때문입니다 ㅠ  \r\n\r\n이건 제가 Scheme한 부분입니다. \r\n![](https://velog.velcdn.com/images/damin1025/post/dd2ad444-f17c-4215-9d85-52ff52623c6d/image.jpg)\r\n이런식으로 본인이 스스로 한번 구상하시는 것을 추천드립니다 🐣 그리고 포스팅을 읽을때, TOC 컴포넌트가 **일정 위치에 고정**되도록 구현하고 싶었기 때문에 `Sticky` 속성을 부여했습니다. \r\n\r\n또한 다크모드로 전환 시, 콘텐츠들의 글자색들이 바뀌어야 하기 때문에 body의 classList가 'dark'면 바뀔 수 있도록 값을 부여했습니다. \r\n\r\n```css\r\na {\r\n\tcolor: ${\r\n    isBrowser() && window.document.body.classList.contains('dark')\r\n\t};\r\n    text-decoration: none;\r\n}\r\n```\r\n\r\n## Scroll시 각 header에 맞게 Active 기능 부여하기\r\n\r\nScroll시 각 Header에 맞게 Active하는 기능을 어떻게 구현해야 하는지를 고민해봤을때, 저는 Scroll값과 offsetTop값을 활용하여 처리하는 것으로 구상했습니다. \r\n\r\n`InterSectionObserver` API를 활용하는 것이 물론 퍼포먼스적으로 좋다는 지표도 있지만, 우선 아직 저의 무지함으로 인해.. 구상부터 잘 이루어지지 않았습니다🙁.. Learning Curve가 있기에 좀 더 익숙해지면 해당 방법으로 마이그레이션을 고려할 수 있을것 같습니다.  \r\n\r\n따라서 제가 생각한 방법은 Scroll값에 따라 headings 배열을 돌면서 일정 offsetTop 값에 도달하면 Index 값을 참조하여 active 할 수 있는 방법은 어떨까? 로 구상했고 이 방법으로 구현에 진행할 수 있었습니다. \r\n\r\n```tsx\r\n// PostTOC.tsx\r\nconst calcActive = useCallback(() => {\r\n    if (!isBrowser) {\r\n      return 0\r\n    }\r\n    const offsets: number[] = []\r\n\r\n    // bring each headings offsetTop\r\n    for (const { slug } of headers) {\r\n      const element = document.getElementById(slug)\r\n      if (!element) {\r\n        return\r\n      }\r\n      offsets.push(element.offsetTop - 10)\r\n    }\r\n\r\n    const maxIndex = offsets.length - 1\r\n    const { scrollY } = window\r\n    let index = 0\r\n\r\n    // Scroll Active Trigger (looping the offset)\r\n    if (scrollY === 0 || scrollY <= offsets[0]) {\r\n      index = 0\r\n    } else if (\r\n      window.innerHeight + scrollY >= document.body.scrollHeight ||\r\n      scrollY >= offsets[maxIndex]\r\n    ) {\r\n      index = maxIndex\r\n    } else {\r\n      index = findIndex(offsets, offset => offset >= scrollY) - 1\r\n    }\r\n    return index\r\n  }, [headers])\r\n```\r\n\r\n`headers` 배열을 참조하여 value를 slug화 한 각각의 태그를 `element`로 불러오고, 각각의 offsetTop 값을 `offsets` 배열에 담습니다. 다시 말하면 `offsets` 배열은 document 기준의 각 header들의 위치를 의미합니다. \r\n\r\n그리고 스크롤 할때마다 Y축의 값을 반환하는 `scrollY` 를 통해서, 3가지 상황으로 조건문을 분기할 수 있습니다. (사실 글보단 코드가 더 이해가 잘 될것 같긴 합니다😅)\r\n\r\n1. 만약 `scrollY` 값이 0(맨위) 또는 `offsets[0]`(가장 첫번째 header 문구) 보다 작거나(닿기직전) 해당 위치에 도달 했다면? : **index = 0으로 부여** \r\n\r\n2. `scrollY` 값이 `offset[maxIndex]`보다 크거나 같을때(마지막 header문구 위치와 같거나 지나쳤을때) 또는 window의 innerHeight와 `scrollY` 를 합친 값이 document 기준의 scrollHeight보다 크거나 같을때(마지막 header문구를 지나친건 아니지만, ScrollHeight(스크롤하지 않았을때 전체 높이)를 넘겼을때) : **index = maxIndex로 부여** \r\n\r\n3. 1,2에 해당하지 않을때 \r\n\r\n그래서 이 `index`를 활용해서 event를 trigger합니다. \r\n```tsx\r\n// PostTOC.tsx\r\nconst [currentIndex, setCurrentIndex] = useState<number | undefined>(0)\r\n\r\n  useEffect(() => {\r\n    setCurrentIndex(calcActive())\r\n    const onScrollForActive = throttle(() => setCurrentIndex(calcActive()), 300)\r\n    window.addEventListener('scroll', onScrollForActive)\r\n\r\n    return () => {\r\n      onScrollForActive.cancel()\r\n      window.removeEventListener('scroll', onScrollForActive)\r\n    }\r\n  }, [calcActive])\r\n```\r\n`useEffect()` Hook을 활용하여 `calcActive`에 따라 event가 Trigger될 수 있도록 dependency Array에 할당합니다. \r\n\r\n이때 Scroll시, 매번 offsetTop 값과 ScrollY값을 연산해야 하기 때문에 싱글 스레드에 조금이라도 최적화 하는 작업이 필요합니다. 왜냐하면 Scroll시, 매번 연산하기 때문에 console을 찍어보면 값들이 무수히 찍히기 때문입니다.\r\n\r\n따라서 저는 [lodash-es](https://www.npmjs.com/package/@types/lodash-es)에서 제공하는 `throttle()` 메소드를 활용하여 Scroll Event를 최적화 했습니다. 이는 Scroll시 매번 요청되는 call을 `SetTimeOut()` 연산과 같은 구조로, 300ms를 기다렸다가 `onScrollForActive`를 요청합니다. \r\n\r\n```tsx\r\n// PostTOC.tsx\r\n<ol>\r\n{headers.map(({ value, depth }, idx) => (\r\n\t<li\r\n    key={idx}\r\n    style={{ paddingLeft: `${depth * 11}px` }}\r\n    className={currentIndex === idx ? 'active' : ''}\r\n    >\r\n\t\t// ...\r\n\t</li>\r\n    ))}\r\n</ol>\r\n```\r\n`calcActive()` 함수의 리턴 index가 `useState` Hook의 현재 state로 담기는 `currentIndex`에 담기면서, 실제 ol 태그내에서 headers 배열(`PostTOC` 컴포넌트 상단에서 `useMemo()`를 통해 연산한 값을 재사용 했습니다.) 을 도는 idx 값과 비교하게 되면서 `currentIndex`와 일치하는 idx에 대해서만 active 활성화를 부여하게 되면, Scroll시 bold체로 활성화 되는 것을 볼 수 있습니다. \r\n\r\n(*`li`태그 에서 style은 indentation을 주기 위해서 depth를 활용한 것입니다.)\r\n\r\n## header에 맞는 href로 이동하기 \r\n그리고 `a` 태그에 href 값으로 `slug(value)`를 할당하게 되면 헤더에 맞는 위치로 이동하게 됩니다. \r\n\r\n```tsx\r\n// PostTOC.tsx\r\n//...\r\n<a data-idx={idx} href={`#${slug(value)}`}>\r\n\t{value}\r\n</a>\r\n//...\r\n```\r\n\r\n### 🪓 Issue Handle  \r\n![2023-05-16 11;09;11](https://github.com/dobyming/dobyming.github.io/assets/90133704/d9c2b8db-6934-4e50-9e93-bc0d5eb196f3)\r\n\r\nTesting을 하던 중, console에 이런 error log가 찍혔습니다. 공통점을 보니, 숫자로 시작하는 헤더를 `querySelector`가 parsing을 수행할 수 없다는 류의 에러였습니다. (TOC 컨테이너에 해당하는 헤더값을 클릭 시, 해당하는 헤더로 이동하지도 않았습니다.) \r\n\r\n```tsx\r\nconst heading = document.querySelector<HTMLHeadingElement>(href)\r\nif (!heading) {\r\n\treturn\r\n}\r\n\r\nwindow.scrollTo({\r\n\ttop: heading.offsetTop,\r\n  behavior: 'smooth',\r\n })\r\n```\r\n\r\n문제가 발생한 코드였고 [StackOverflow](https://stackoverflow.com/questions/37270787/uncaught-syntaxerror-failed-to-execute-queryselector-on-document)에서 보니, `querySelctor`는 숫자로 시작하는 heading은 인식하지 못한다는 것이었습니다. 따라서 위의 코드는 과감히 제거하고, `a` 태그의 `href`에 slug화 한 value를 할당하여 숫자로 시작하는 slug도 인식할 수 있도록 트러블 슈팅을 진행했습니다. \r\n\r\n## 🔮 후기 \r\n일주일 가까이? 시간을 쏟고 나름 고생하면서 만들었네요.. 기능 개발에서 많은 고민과 시간을 투자해서 그런지 더 소중하게 다가옵니다. 의외로 CSS 스타일링도 내가 아는게 다 아니었구나를 또 깨달으며 역시 계속 배워야 한다는 것을 깨달았던 feature 개발이었습니다. \r\n\r\n성능상 최적화해야 할 부분이 남은 숙제겠네요! 그래도 스스로 TOC 기능을 만든건 꽤나 뿌듯합니다.😊"},{"id":"002719e2-0a56-5460-ac23-069cce2dd50e","path":"/Develop/Gatsby-Trouble-Shooting/","title":"Gatsby 블로그 - 개발하면서 만났던 Issue","body":"`Gastby` 프레임워크를 활용하여 블로그를 구현하고 운영한지 어느덧 2달이 다 되가고 있네요.. 다양한 기능들을 블로그에 하나씩 덧붙혀가면서 동시에 에러도 같이 늘어났었는데요 😅 \r\n\r\n이 기간동안 제가 접한 Issue들과 어떻게 해결하려고 노력했는지를 여러분께 공유하려고 해요. \r\n\r\n\r\n## #418 #423 Minified Error \r\n어느정도 블로그를 구현하고 배포하면서 lightHouse로 Performance 점수를 측정하는데 Best Practices 부문에서 자꾸 92점이라는 Score가 찍혀있었고, 해당 원인으로는 Console log에 에러가 찍히는데? 라고 알려주더라구요. \r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/f8871c18-0dc4-4b03-be52-0fcf92b7ab65/image.PNG)\r\n\r\nLightHouse에서 말한 이슈가 이걸 의미하는걸까 싶었고 또한 콘솔에 많은 에러가 찍혀있는건 개발자 입장에서도 매우 거슬렸기 때문에 이를 본격적으로 해결하고자 했어요.\r\n\r\n[해당 블로그](https://vaihe.com/blog/react-hydration-error-explained/)에서 그 원인을 찾을 수 있었어요. 이 에러의 정확한 명칭은 **React Hydration** 에러이고, 이 에러는 Client Render와 Server Render가 일치하지 않을때 발생한다고 해요. \r\n\r\nGatsby는 Pre-Render되는 속성이 있기 때문에, 이때 이 Pre-Render되는 HTML 파일과 React(대표적 CSR 라이브러리이자 Gatsby의 근간)에서 Virtual Dom으로 쌓아올린 HTML 파일과 <span style=\"color:red\">일치하지 않아서 발생하는 거예요.</span> 그래서 Pre-Render된 HTML 파일이 렌더링이 되는 것이 아니라 자체적으로  React가 쌓아올린걸로 replace 되버리는 거죠. \r\n\r\n이렇게 되버리면 우리는 Gatsby의 장점을 살릴 수 없어요 😱\r\n\r\n### 해결\r\n결국엔 모든 문제는 Server와의 연산이 요구되는 코드에서 에러가 발생하는거라고 판단했어요. Pre-Render 시에는 Server 연산을 참조하지 못하는데요, 대표적으로 `window` 객체라는게 뭔지도 모르는 상태에서 요청하면 안되기 때문에 이를 Validation하는 작업이 필요해요.\r\n\r\n제 블로그에서 첫 index page를 load 할때 가장 의심이 가는 부분은 바로 다크모드를 handle할 수 있는 `HeaderTheme` 컴포넌트였어요. 왜냐하면 localStorage를 참조하여 dark인지 light인지를 담는 연산을 수행하고 있기 때문이에요. \r\n\r\n그래서 `HeaderTheme`의 토글 버튼이 로딩을 **lazy loading**으로 수행함으로써 이 문제를 해결할 수 있었어요. \r\n\r\n```tsx\r\n// ClientOnly.tsx\r\nimport React, { useState, useEffect, ReactNode, FunctionComponent } from 'react'\r\n\r\ntype ClientProps = {\r\n  children: ReactNode\r\n}\r\n\r\nconst ClientOnly: FunctionComponent<ClientProps> = function ({ children }) {\r\n  const [isMounted, setIsMounted] = useState<boolean>(false)\r\n\r\n  useEffect(() => {\r\n    setIsMounted(true)\r\n  }, [])\r\n\r\n  if (!isMounted) {\r\n    return null\r\n  }\r\n\r\n  return <>{children}</>\r\n}\r\n\r\nexport default ClientOnly\r\n```\r\n`ClientOnly`를 `HeaderTheme` 컴포넌트의 최상단으로 배치해서 HTML 파일이 모두 성공적으로 load후 토글버튼을 리턴하는 방식으로 이 문제를 해결할 수 있었어요.\r\n\r\n이건 실제로 제가 해결한 [PR](https://github.com/dobyming/dobyming.github.io/pull/16#issue-1723164020) 이에요.\r\n\r\n## SVG Icon Flicker Issue \r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/c555ab5e-d15c-482f-925e-ead9b3db00ab/image.gif)\r\n\r\n이건 GIF를 보면서 설명하면 더 이해가 잘될것 같아요. \r\n혹시 `<-` 아이콘이 갑자기 Resizing이 일어나고 그리고 Dark mode Toggle 버튼은 해->달로 잠깐 깜빡이는것을 목격하셨나요? \r\n\r\n기능은 정상적으로 수행은 되는 버튼이라도, 이런 자잘한 에러들은 UX를 떨어트리는 요소라고 생각했어요. \r\n\r\n우선 `<-` 버튼 같은 경우는 `fontAwesome`에서 icon을 import하여 사용하고 있었어요. 그리고 이 Resizing 에러가 발생한 원인은 다음과 같았어요.\r\n\r\n> Instead, they are downloaded through a separate network request and then inserted into the document using Javascript. It’s essentially DOM manipulation, which is how React (which underlies Gatsby) works. Only this time, instead of manipulating UI elements like `<div>`, it is inserting a `<style>` element. Essentially, the styles are downloaded externally and inserted into the document through DOM manipulation. ([출처](https://medium.com/@fabianterh/fixing-flashing-huge-font-awesome-icons-on-a-gatsby-static-site-787e1cfb3a18))\r\n\r\n요약하면, 해당 icon이 inline하게 HTML에 insert되는게 아니라 `style` 태그로 삽입되어서 **외부적**으로 download가 이뤄진 후에 DOM에 삽입이 되어서 이런 이슈가 발생하는거라고 해요. 즉 Gatsby에선 이 icon이 CSS가 load되어 삽입되기 전에 이미 존재하기 때문에 Resize되는 현상을 목도하게 되는거에요. \r\n\r\n따라서 이 문제는 icon이 CSS에 Auto Add 되는것을 막으면 해결할 수 있어요. 즉 `inline`하게 설계해야 하는거죠. FontAwesome의 Config setting을 통해 쉽게 해결할 수 있어요. 그러면 build time에 해당 icon이 내장하게 되요. \r\n\r\n```js\r\n// gatsby-browser.js\r\nimport '@fortawesome/fontawesome-svg-core/styles.css'\r\nimport { config } from '@fortawesome/fontawesome-svg-core'\r\n\r\nconfig.autoAddCss = false;\r\n```\r\n<br/>\r\n\r\n### useEffect와 useLayoutEffect 적절히 사용하기\r\n다음으론 다크모드 토글버튼의 상태값이 해->달로 잠깐 보였다가 사라지는 이슈를 해결할 차례예요. 우선 React Developer Tool로 State의 감지를 살펴봤을땐 boolean값이 잠깐 바뀌는 현상이 일어나진 않았어요. \r\n\r\n그럼 뭐가 문제인걸까 생각했을때, 이벤트가 Trigger되는 시점에 대해서 생각해보게 됐어요. 저는 다크모드 토글이 이뤄지는 이벤트 Trigger를 `useEffect` 리액트 훅을 이용하여 Trigger했었는데, 이에 대적하는 `useLayoutEffect` 리액트 훅에 대해서 알아보기로 했어요. \r\n\r\n사실 기업 면접에서 `useEffect` 와 `useLayoutEffect`의 차이점을 아세요? 라는 질문을 받았던 경험이 있었는데 슬프게도 대답을 못했고, 또한 사용해보지 않은 Hook 이었기 때문에 이참에 더 알아보기로 했어요. 이 [블로그](https://pubudu2013101.medium.com/what-is-the-real-difference-between-react-useeffect-and-uselayouteffect-51723096dc19)에서 많은 도움을 받았어요.\r\n \r\n두 리액트 훅의 결정적 차이는 바로 **시점**으로 볼 수 있어요. \r\n#### useEffect\r\nuseEffect 는 컴포넌트들이 **render 와 paint** 된 후 실행돼요. 즉 비동기적(asynchronous) 으로 실행되고, paint된 후 실행되기 때문에 useEffect 내부에 DOM에 영향을 주는 코드가 있을 경우 사용자 입장에서는 화면의 flicker 현상을 볼 수 있어요. \r\n\r\n#### useLayoutEffect\r\nuseLayoutEffect 는 컴포넌트들이 **render 된 후 실행되며**, 그 이후에 paint 되요. 이 작업은 동기적(synchronous) 으로 실행되며 paint 가 되기전에 실행되기 때문에 DOM을 조작하는 코드가 존재하더라도 사용자는 깜빡임을 경험하지 않아요.\r\n\r\n\r\n```tsx\r\n// trigger theme change refer localStorage's key-value\r\n  useEffect(() => {\r\n    if (userTheme === 'dark') {\r\n      document.body.classList.remove('light')\r\n      document.body.classList.add('dark')\r\n      setIsDark(true)\r\n    } else {\r\n      document.body.classList.remove('dark')\r\n      document.body.classList.add('light')\r\n      setIsDark(false)\r\n    }\r\n  }, [userTheme])\r\n```\r\n기존 코드를  보면, `document` 객체에 접근하죠? 그리고 `useEffect`로 이를 Trigger하고 있기 때문에 현재 state가 flicker되는 현상을 볼 수 있었던거예요. \r\n\r\n이때 주의할 점은 `useLayoutEffect`는 paint되기 전에 실행되기 때문에 **React Hydration Issue** 를 만날 수 있는데 (클라이언트화면 !== 서버화면) 이는 상단에 제가 언급한 Minified error와 맞물리기 때문에 해당 validation을 최상단 컴포넌트에서 감아주면 문제를 해결할 수 있어요. \r\n\r\n### gatsby-plugin-offline 활용하기\r\n그리고 추가적으로 `gatsby-plugin-offline` 설치를 하게 되면 깜빡임 현상을 더욱 최소화 할 수 있어요. `gatsby-plugin-offline`은 **Service Worker**를 활용해서 작동합니다. 그럼 서비스워커는 무엇일까요?\r\n> 서비스 워커는 웹 응용 프로그램, 브라우저, 그리고 (사용 가능한 경우) 네트워크 사이의 프록시 서버 역할을 합니다. 서비스 워커의 개발 의도는 여러가지가 있지만, 그 중에서도 효과적인 오프라인 경험을 생성하고, 네트워크 요청을 가로채서 네트워크 사용 가능 여부에 따라 적절한 행동을 취하고, 서버의 자산을 업데이트할 수 있습니다. 또한 푸시 알림과 백그라운드 동기화 API로의 접근도 제공합니다. (출처: [MDN](https://developer.mozilla.org/ko/docs/Web/API/Service_Worker_API))\r\n\r\n![gatsby-service-worker](https://github.com/dobyming/dobyming.github.io/assets/90133704/9ab3f2eb-f665-4c5c-aeec-9f83ee2264da)\r\n\r\n페이지를 최초 요청할때 static한 asset들(SVG Icon)을 내려 받고, CacheStorage에 저장을 합니다. 따라서 유저가 향후 웹사이트를 재방문할때 유저의 Cache Storage에 저장된 assets들을 참고하여, 빠르게 불러올 수 있습니다. 그렇기 때문에 깜빡임 현상을 최소화 할 수 있습니다. \r\n\r\n이때 config options를 통해서 어느 페이지 또는 어떤 폴더에 대해서만 Cache에 담을 지 부여할 수 있어요. 이 Option이 필요한 이유는 역시 사용자 경험과 밀접한 연관을 맺고 있어요. 만약 최초로 방문하는 유저일 경우에는 모든 리소스들을 Cache에 담는 작업이 수행된다면, 사용자별로 Cache 사이즈도 상이하고 그리고 Band-width도 상이하기 때문에 어떤 환경에서는 빠를지 몰라도, 또 다른 유저는 느리게 느껴질 수도 있어요. \r\n\r\n따라서 아래와 같이 내가 어떤 상황에서만 cache작업을 하겠다는 것을 부여할 수 있습니다. \r\n```js\r\n{\r\n    resolve: `gatsby-plugin-offline`,\r\n    options: {\r\n        precachePages: [`/blog/*`],\r\n    },\r\n}\r\n```\r\n\r\n### 결과물\r\n위 과정들을 거치고 나면..!\r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/c03d5350-d60b-44e2-a565-04f092e6f3b2/image.gif)\r\n\r\n더이상은 해로 잠깐 보였다가 사라지는 현상은 볼 수 없게 되요😙\r\n\r\n## Ongoing..\r\nGatsby로 이것저것 접목해서 블로그를 만들면서 가장 많이 접한 개념은 브라우저의 작동방식이었어요. 실제로 개발을 진행하면서 CSR, SSR, SSG와 같이 렌더링에 대한 개념을 기존보다 더 딥하게 체감하며 개념의 중요성을 깨달을 수 있었던 좋은 트러블 슈팅을 경험했다고 생각해요. \r\n\r\n### +) 23.05.29 LightHouse 점수 💯\r\n![](https://velog.velcdn.com/images/damin1025/post/89bfd0af-9bac-4670-b46e-c27acc9d1d00/image.PNG)\r\n\r\nPerformance에서 2점이 부족한데.. 400점을 받는 그날까지 계속해서 성능 튜닝을 진행할 예정입니닷..!👊\r\n\r\n### 🙇🏼‍♀️참고\r\n**React Hydration Issue**\r\n\r\nhttps://www.codeandweb.com/tutorials/gatsby-lazy-loading-with-react-lazy\r\n\r\nhttps://egghead.io/lessons/react-avoiding-state-flickers-in-gatsby-applications\r\n\r\nhttps://vaihe.com/blog/fixing-gatsby-hydration-flicker-issue/\r\n\r\n**Gastby SSR Issue(함께 읽으면 좋음)**\r\n\r\nhttps://stackoverflow.com/questions/64371186/gatsby-window-not-available-during-server-side-rendering-build-error\r\n\r\nhttps://www.gatsbyjs.com/docs/debugging-html-builds/#how-to-check-if-window-is-defined"},{"id":"0f50d653-27c0-5986-9a18-da9e1d08e557","path":"/Develop/Gatsby-다크모드-구현기/","title":"Gatsby 블로그 - 다크모드 구현기🌗","body":"\r\n우선 글을 시작하기 전에.. 5월 24일 부로 블로그 개발을 시작한지 1달 넘은 시점에서 100개의 commit을 달성했습니다..🥳\r\n\r\n<div style=\"text-align:center\"><img src=\"https://velog.velcdn.com/images/damin1025/post/0e0117f4-e670-4a3c-a849-c5eadf34c786/image.PNG\" /></div>\r\n\r\n\r\n저에게 이 `개발 블로그` 프로젝트는 **프론트엔드가 뭔지 제대로 보여준** 프로젝트나 다름 없어서 배운게 정말 많은 고마운 프로젝트입니다. 만약 프론트엔드를 내 커리어패스로 밟고 싶다고 한다면 자신만의 블로그 만드는 것을 적극 추천할 정도로 배울게 정말 많고 좋은 프로젝트라고 생각합니다. \r\n\r\n사족은 여기서 마무리 짓고.. 다크모드를 구현하면서 겪은 제 삽질기를 나열해보겠습니다 🤪...\r\n\r\n\r\n## 동기 \r\n이 프로젝트를 처음 구상하고 그리고 기능들을 하나씩 만들어 나갈때 세운 목표 중 하나가 다크모드는 꼭 만들어야지..! 생각했습니다. 특히 프론트엔드에서 이제 없으면 허전할 정도라고 볼 수 있는 **다크모드🌗** 기능을 Gatsby와 어느정도 친해지면 제대로 파야겠다 생각했고 때가 온 것이었습니다. \r\n\r\n일전에 React를 배우기 위해서 [Emotionary](https://github.com/dobyming/Emotionary) 프로젝트를 진행 중, `Provider` 개념을 활용하여 최상위 컴포넌트에서 `theme` props를 전달하여 다크모드를 구현했던 경험이 있었고, Gatsby에서도 이런 개념을 활용하면 되려나? 생각으로부터 시작하며 구현에 Dive 했습니다. \r\n\r\n## Theme을 어떻게 전달할 것인가 : ThemeProvider VS CSS Variable\r\n대략적인 Mock Up은 이렇게 구상했었습니다.\r\n>토글 버튼이 있음(component) -> 클릭 값(state)에 따라 어떤 theme을 보여줄지 결정할 것. (boolean 속성으로 true면 dark, false면 light) \r\n\r\n그리고 이때 `theme`을 어떻게 전달할 것인가? 이게 관건이었습니다.  \r\n\r\n### 🤔 emotion의 ThemeProvider로 삽질 \r\n~~오래전에 수행한 삽질이라 기억이 약간 가물하네요...ㅠ~~\r\n\r\n기존에 `Provider`를 활용하여 구현해 본 경험이 있었기 때문에 마침 `emotion`에서 `ThemeProvider` Theme package를 지원하고 있었고 저 역시 이걸로 구현해야겠다 생각하며 코드 구현에 진행했지만, ... build는 커녕 develop 단계에서부터 error를 만나게 되어 머리를 싸맸습니다.\r\n\r\n### 🥰 CSS Variable로 광명을 찾다 \r\n'토글 버튼의 클릭 값에 따라 어떤 theme을 보여줄 지..' 이 문장에서 CSS Variable과 엮을 수 있습니다. \r\n\r\n```tsx\r\n// trigger theme change refer localStorage's key-value\r\n useLayoutEffect(() => {\r\n\tif (userTheme === 'dark') {\r\n    document.body.classList.remove('light')\r\n    document.body.classList.add('dark')\r\n    setIsDark(true)\r\n\t} else {\r\n    document.body.classList.remove('dark')\r\n    document.body.classList.add('light')\r\n    setIsDark(false)\r\n    }\r\n }, [userTheme])\r\n```\r\n여기서 `userTheme`이 현재 state이고, 그 state가 `dark`라면 `body` 태그의 className을 `dark`라고 지정하고, 그 반대면 `light`로 지정합니다. \r\n\r\n그러면 이 `body` 태그의 className에 따라서 CSS Variable로 지정할 수 있었습니다.   \r\n```css\r\n/*theme.css*/\r\n\r\n.light {\r\n    --color-background:#f6f6f6;\r\n}\r\n\r\n.dark {\r\n    --color-background: #25262c;\r\n    --color-text: #f6f6f6;\r\n}\r\n\r\nbody {\r\n    background-color: var(--color-background);\r\n    transition: 0.2s;\r\n}\r\n\r\nh1,\r\nh2,\r\nh3,\r\nh4,\r\nh5,\r\nhr,\r\na,\r\np,\r\nli,\r\ntd,\r\ntr,\r\nfooter,\r\nspan {\r\n  color: var(--color-text);\r\n}\r\n```\r\n`theme.css` 파일에 위와 같이 정의할 수 있습니다. 상단에는 body의 className에 따라서 어떤 css 속성 값을 부여할 지 rgb 값을 정의합니다. 그리고 **원하는 태그에 원하는 CSS Variable**을 지정할 수 있습니다. 이런 로직으로 수행하면 전체적으로 개발 블로그에 다크모드가 적용됨을 볼 수 있습니다. \r\n\r\n그리고 실제로 Provider를 활용해 다크모드를 구현하는 것보단, CSS Variable을 활용하여 구현한 것이 **성능적인** 측면에서도 더 좋은 지표를 보여줬습니다. \r\n[Dark Mode Theme PR](https://github.com/dobyming/dobyming.github.io/pull/11) 해당 링크로 가시면 제가 왜 CSS Variable을 선택하여 구현에 진행했는지 자세한 지표와 설명을 볼 수 있습니다. \r\n\r\n>+) 추가로 SVG Icon에 다크모드를 어떻게 적용해야 할 지 막막한 분들께 간략한 코드를 보여드리고자 합니다. (사실 내가 바보여서 헷갈려했음..)\r\n\r\n우선 SVG 같은 경우에는 색상이 담길 수 있도록 `fill`과 `stroke` 속성을 지정 해야합니다. `fill`은 채워지는 색이고 `stroke`는 테두리색입니다. 그러므로 `.svg` 파일에서 **`path` 태그 내에 fill과 stroke 속성을 current**로 지정합니다.\r\n\r\n```svg\r\n// 예시 svg\r\n<svg width=\"30px\" height=\"30px\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\r\n<path fill=\"current\" stroke=\"current\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M15.7071 4.29289C16.0976 4.68342 16.0976 5.31658 15.7071 5.70711L9.41421 12L15.7071 18.2929C16.0976 18.6834 16.0976 19.3166 15.7071 19.7071C15.3166 20.0976 14.6834 20.0976 14.2929 19.7071L7.29289 12.7071C7.10536 12.5196 7 12.2652 7 12C7 11.7348 7.10536 11.4804 7.29289 11.2929L14.2929 4.29289C14.6834 3.90237 15.3166 3.90237 15.7071 4.29289Z\" fill=\"#000000\"/>\r\n</svg>\r\n```\r\n\r\n그럼 색상을 지정하고자 하는 SVG Icon에 className을 부여한 후, 자신이 정의한 theme css 파일에 마찬가지로 CSS Variable로 지정하면 끝입니다! \r\n```css\r\n.githubIcon path {\r\n    fill: var(--color-text);\r\n}\r\n```\r\n\r\n## Flicker Issue 에러 해결하기\r\n다크 모드 구현에 대한 틀을 잡았다는 기쁨도 잠시, 페이지를 reload 시  분명 이런 깜빡임 현상을 겪을 것입니다...\r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/58ff2ef6-95a9-4fea-b04d-3520fb34a879/image.gif)\r\n\r\n못봤다구요? 저도 그냥 잠시 일시적으로 아주 잠깐 이러는거 아닐까..? ㅎㅎ 했는데 아니더라구요 😣 아주 유명한 <span style=\"color:red\">**Flicker Issue**</span> 였습니다. \r\n\r\n>The problem is that the HTML is generated long before it reaches the user's device, so there's no way to know which color theme the user prefers. [참고](https://www.joshwcomeau.com/css/css-variables-for-react-devs/#dark-mode-flash-fix)\r\n\r\n해당 Issue가 발생한 원인으로는, Gatsby가 HTML 파일을 빌드하는 `Pre-Render` 특성과 밀접한 관련이 있습니다. 비록 localStorage로 사용자가 설정한 theme을 저장한다고 해도, **reload 시 localStorage를 참조하는건 Pre-Render 시점이 아닌 그 이후 시점에 참조**하기 때문에 이런 현상이 발생하게 됩니다. \r\n\r\n즉 이 문제를 해결하기 위해서는, localStorage를 참조하는 시점을 DOM 트리가 구축되기 이전에 Script 파일을 강제로 Injection하는 부분의 코드 작업이 필요했습니다. 그리고 Gatsby에서는 **`html.js` 파일을 통해 Script 파일을 inject 할 수 있도록 customize**를 허용합니다. \r\n\r\n>💖 [Gatsby html.js customize](https://www.gatsbyjs.com/docs/custom-html/) docs에 `html.js` 파일을 생성하는 부분에 대해 자세한 설명이 있으므로 꼭 docs를 읽으시고 진행하시길!!\r\n\r\n그럼 `html.js` 파일이 생성됐고, 저는 아래와 같이 customize를 진행했습니다. \r\n```js\r\n// html.js\r\nimport React from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nexport default class HTML extends React.Component {\r\n  render() {\r\n    return (\r\n      <html {...this.props.htmlAttributes}>\r\n        <head>\r\n          <meta charSet=\"utf-8\" />\r\n          <meta httpEquiv=\"x-ua-compatible\" content=\"ie=edge\" />\r\n          <meta\r\n            name=\"viewport\"\r\n            content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\r\n          />\r\n          {this.props.headComponents}\r\n        </head>\r\n        <body {...this.props.bodyAttributes} className=\"light\">\r\n          <script\r\n            dangerouslySetInnerHTML={{\r\n              __html: `\r\n\t\t\t// Customize 할 부분\r\n              (function () {\r\n                try {\r\n                  var mode = localStorage.getItem('color-theme');\r\n                  if (!mode) return;\r\n                  document.body.classList.add(mode);\r\n                } catch (e) {}\r\n              })();\r\n            `,\r\n            }}\r\n          />\r\n          {this.props.preBodyComponents}\r\n          <div\r\n            key={`body`}\r\n            id=\"___gatsby\"\r\n            dangerouslySetInnerHTML={{ __html: this.props.body }}\r\n          />\r\n          {this.props.postBodyComponents}\r\n        </body>\r\n      </html>\r\n    )\r\n  }\r\n}\r\n\r\nHTML.propTypes = {\r\n  htmlAttributes: PropTypes.object,\r\n  headComponents: PropTypes.array,\r\n  bodyAttributes: PropTypes.object,\r\n  preBodyComponents: PropTypes.array,\r\n  body: PropTypes.string,\r\n  postBodyComponents: PropTypes.array,\r\n}\r\n```\r\nDOM 트리가 구축되기 직전에 localStorage를 참조하여 미리 Theme이 setting 될 수 있도록 Script를 주입했습니다. 아래와 같이 해당 Dark mode flicker issue를 해결할 수 있었습니다. \r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/9818ade3-3dbd-4eca-a24f-0eaf7c0f70a1/image.gif)\r\n\r\n실제 deploy된 element 코드를 보면 script injection이 잘 됐음을 볼 수 있습니다. \r\n\r\n![](https://velog.velcdn.com/images/damin1025/post/c6c1144e-5caa-490d-b842-7ee175488c7c/image.PNG)\r\n\r\n## 🔮 Utterance에 다크모드 적용하기 \r\n제 개발 블로그에는 댓글 기능으로 `Utterance` 오픈 소스를 활용하고 있습니다. \r\n\r\n이때 Utterance는 다른 요소들과는 달리, `Div` element를 직접 생성하고 그리고 `attributes`에 repo 등등 속성을 지정하고 그리고 그 지정한 값에 대해서 DOM 트리에 appendChild 하여 생성되기 때문에 다크모드 구현에 대해 CSS Variable로 어떻게 지정해야 되는지 구상이 잘 떠오르지 않았습니다.\r\n\r\nUtterance 요소는 `Div`로 생성되지 않고 `iframe`으로 생성됩니다. \r\n따라서 `iframe` 태그에 접근하여 theme을 바꾸는 부분을 `window.postMessage()`로 전달하여 접근했어야 했습니다.\r\n\r\n> `window.postMessage()` 메소드는 Window 오브젝트 사이에서 안전하게 cross-origin 통신을 할 수 있게 합니다. 예시로, 페이지와 생성된 팝업 간의 통신이나, 페이지와 페이지 안의 iframe 간의 통신에 사용할 수 있습니다. (출처: [MDN](https://developer.mozilla.org/ko/docs/Web/API/Window))\r\n\r\n제 프로젝트에서 **다크모드의 전환 유무의 포인트는 body의 className**입니다. light냐 dark냐에 따라서 DOM 트리가 구축될때, body의 className에 따라 유동적으로 변화할 수 있는 idea가 필요했습니다. 구글링 결과, `MutationObserver` 라는 Constructor가 이 개념을 활용할 수 있다고 판단했습니다. [참고](https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/)\r\n\r\n```tsx\r\nuseEffect(() => {\r\n    const mutationObserver: MutationObserver = new MutationObserver(\r\n      mutationsList => {\r\n        mutationsList.forEach(mutation => {\r\n          if (mutation.attributeName === 'class') {\r\n            if (window.document.querySelector('.utterances-frame')) {\r\n              const theme = mutation.target.classList.contains('dark')\r\n                ? 'photon-dark'\r\n                : 'github-light'\r\n              const message = {\r\n                type: 'set-theme',\r\n                theme: theme,\r\n              }\r\n              const iframe =\r\n                window.document.querySelector('.utterances-frame')\r\n              iframe.contentWindow.postMessage(message, src)\r\n            }\r\n          }\r\n        })\r\n      },\r\n    )\r\n    mutationObserver.observe(document.body, { attributes: true })\r\n  }, [])\r\n```\r\n감지된 body의 className에 따라 삼항연산자로 theme을 할당 후, iframe에 postMessage()로 message를 전달합니다. 그리고 `attributes`의 상태값을 true로 지정하여, body의 class의 변화를 감지할 수 있도록 수행합니다. \r\n또한 이 이벤트를 mount 시점에 trigger 될 수 있도록 `useEffect()` Hook내에 선언했습니다. 이는 index(홈 화면)에서 다크 모드로 토글 후, 포스트를 클릭하여 utterance theme이 바로 적용될 수 있도록 하기 위함입니다. \r\n\r\n### 결과물\r\n![](https://velog.velcdn.com/images/damin1025/post/c7799ac4-2bbe-466e-95ca-d1c33a3a491e/image.gif)\r\n\r\n휴 .. 개인적으로 어려웠던 부분 중 하나였는데 잘 작동해서 어찌나 행복하던지💙\r\n\r\n\r\n## 마무리 \r\n사실 이 글을 쓰면서 엥 이것밖에 안된다고? 생각이 들 정도로, 다크모드 구현은 꽤나 복잡하고 그리고 꼼꼼함을 기울이는 작업이었습니다. 아무래도 사용자 경험에 큰 영향을 미치는 요소이기 때문에 더욱이 신경을 쓸 수 밖에 없었던 작업이었습니다.  \r\n\r\n어떤 기술을 선택해야 할지, 그리고 어떤 태그에 색상 변화가 필요한지, 또한 렌더링 이슈도 handling 했어야 했고 정말.. 오랜 작업 끝에 어느정도 구색을 갖춘것 같습니다.. (4월말부터 시작했으니..) \r\n\r\n저도 처음으로 제대로 각잡고 만든 다크모드라 부족한 점이 있을 수도 있습니다😂 피드백은 언제나 환영입니다! \r\n\r\n### 🙇🏼‍♀️ 참고 \r\n**-다크모드 CSS Variable 및 flicker Issue-**\r\n\r\nhttps://blog.maximeheckel.com/posts/switching-off-the-lights-part-2-fixing-dark-mode-flashing-on-servered-rendered-website/\r\n\r\nhttps://blog.rhostem.com/posts/2020-06-25-dark-mode-for-gatsby-website\r\n\r\nhttps://github.com/gaearon/overreacted.io/blob/master/src/html.js\r\n\r\n**-Utterance dark mode-**\r\n\r\nhttps://www.sungikchoi.com/blog/gatsby-dark-mode/\r\n\r\n**-MutationObserver-**\r\n\r\nhttps://mong-blog.tistory.com/entry/JS-DOM%EC%9D%84-%EA%B0%90%EC%8B%9C%ED%95%98%EB%8A%94-MutationObserver\r\n\r\nhttps://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/\r\n\r\nhttps://developer.chrome.com/blog/detect-dom-changes-with-mutation-observers/\r\n\r\nhttps://stackoverflow.com/questions/31659567/performance-of-mutationobserver-to-detect-nodes-in-entire-dom\r\n"}]}