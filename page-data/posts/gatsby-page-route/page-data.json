{"componentChunkName":"component---src-templates-post-template-tsx","path":"/posts/gatsby-page-route/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2 id=\"gatsby에서-페이지-라우팅하기\" style=\"position:relative;\"><a href=\"#gatsby%EC%97%90%EC%84%9C-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%9D%BC%EC%9A%B0%ED%8C%85%ED%95%98%EA%B8%B0\" aria-label=\"gatsby에서 페이지 라우팅하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gatsby에서 페이지 라우팅하기</h2>\n<p>Gatsby에서 페이지간 라우팅 하는 방식은 2가지가 있습니다.</p>\n<p>첫번째는 <code class=\"language-text\">a</code> 태그를 활용하는 것입니다. pages 폴더 내에 선언된 파일들은 ‘/파일명’으로 페이지 간 이동이 가능합니다.\r\n하지만 React 기반으로 설계된 프레임워크인 Gatsby를 감히 매번 페이지 이동 시, refresh 되게 구현하면… 이걸로 왜 개발 하냐구요 (UX도 매우 저하되구요)</p>\n<h2 id=\"gatsby-link-api-활용하기\" style=\"position:relative;\"><a href=\"#gatsby-link-api-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"gatsby link api 활용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gatsby Link API 활용하기</h2>\n<p>Gatsby에서 제공하는 페이지 이동 API인  <span style=\"color:red\">Gatsby Link API</span>을 활용하여 페이지 간 라우팅을 구현할 수 있습니다. 이 API를 통해 페이지 이동을 구현하면 보다 더 높은 성능의 정적 사이트를 구현할 수 있습니다.</p>\n<h3 id=\"usage\" style=\"position:relative;\"><a href=\"#usage\" aria-label=\"usage permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Usage</h3>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Link <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'gatsby'</span>\r\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Link</span></span> <span class=\"token attr-name\">to</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/info/<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">To Info</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Link</span></span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>기본적인 사용방법은 위와 같습니다. <code class=\"language-text\">Link</code>를 import 후, Link 태그의 to의 props로 이동할 페이지명을 적어주면 됩니다.</p>\n<p>해당 방식으로 구현 시, a 태그를 사용했을때보다 Link태그를 활용하여 페이지 간 라우팅 방식이 훨씬 더 매끄럽고 속도도 향상됨을 체감할 수 있을 것 입니다.</p>\n<p>그러면 우리는 왜 이럴 수 있는지에 대한 근거까지 알아봐야겠죠</p>\n<h3 id=\"gatsby-link-api의-성능상-이점\" style=\"position:relative;\"><a href=\"#gatsby-link-api%EC%9D%98-%EC%84%B1%EB%8A%A5%EC%83%81-%EC%9D%B4%EC%A0%90\" aria-label=\"gatsby link api의 성능상 이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gatsby Link API의 성능상 이점</h3>\n<p>궁극적인 근거는 Gatsby는 <strong>Prefetch</strong>를 통해서 페이지에서 사용할 리소스의 로딩 속도를 높일 수 있습니다.</p>\n<p>즉 Prefetch는 이와 같은 개념입니다.</p>\n<ol>\n<li>페이지가 로드가 됌 -> 현재 로드된 페이지 내에서 사용되는 모든 링크 찾은 후 -> 각 링크의 페이지를 <span style=\"color:red\">미리</span> 로드</li>\n<li>즉 예를 들면, <code class=\"language-text\">index.tsx</code> 페이지 로드가 됨 -> 동시에 <code class=\"language-text\">Link</code> 태그를 찾음(<code class=\"language-text\">/info</code>) -> 이 페이지(<code class=\"language-text\">info</code>)를 미리 로드해둠</li>\n</ol>","headings":[{"depth":2,"value":"Gatsby에서 페이지 라우팅하기"},{"depth":2,"value":"Gatsby Link API 활용하기"},{"depth":3,"value":"Usage"},{"depth":3,"value":"Gatsby Link API의 성능상 이점"}],"frontmatter":{"title":"Gatsby에서 페이지 라우팅 하는법","summary":"Gatsby에서는 어떤 방식으로 라우팅을 진행할까?","date":"2023.04.17.","categories":["Web","Gatsby"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAANABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAUEBgcJ/8QAFQEBAQAAAAAAAAAAAAAAAAAAAgT/2gAMAwEAAhADEAAAAevkXeWNDrY/Jx//xAAdEAACAgEFAAAAAAAAAAAAAAACBAEFBgADBxMX/9oACAEBAAEFAh5ATnKPUsR6aq3r7tSFFRZ0ABtx/8QAGxEAAgIDAQAAAAAAAAAAAAAAAQIREhBBUWH/2gAIAQMBAT8Bcoa0UpCgNLWltt5PMf/EAB0RAAICAgMBAAAAAAAAAAAAAAEDAhEEEgAUISL/2gAIAQIBAT8ByJ48yvrpkgRTCLBJhZu4Xu0EgaiXnwPBViroc//EACUQAAMBAAEDAgcBAAAAAAAAAAECAwQRBRITFCEABhAkMTI0Qv/aAAgBAQAGPwLT8tP0vqa+njsqOoiLUjU4J6aaESKIaNx6Swn4zWlGfL2y+4HZWj6di0zwve8Bg0aDNY28IX1eQaOmVOh/5XhurG36rXvIUjd0y50ZDSshUw0QBpFvHZQumUXPioGlQheFslJE+SdFV9i5s666IJ01CMxpeY44m9wvkZBwOFLFRwPb2+nbNFRe534RQo76OaUbgf6ejM7n8s7FjySfj//EABkQAQEBAQEBAAAAAAAAAAAAAAERACEQQf/aAAgBAQABPyEjLEp4QJKiIJgcahYFuOLisO8zbbmtGtSJvbXOKdedB8/cQjxSjIZ1SIMXanWf/9oADAMBAAIAAwAAABAgD//EABcRAQEBAQAAAAAAAAAAAAAAAAERIQD/2gAIAQMBAT8QfjBiI7JQjGMJSWHf/8QAGBEBAAMBAAAAAAAAAAAAAAAAARARITH/2gAIAQIBAT8QZ3Jzl6iWmkgMf//EABgQAQEAAwAAAAAAAAAAAAAAAAEAEDGB/9oACAEBAAE/EFOLxCvRNqYKNnjKSiOytuICJmn100DgI1PLXTpXSj4MZMA/AHvsNU2l/9k="},"images":{"fallback":{"src":"/static/0e6a2859511bc04abeba878c5508a73f/f77da/gatsby.webp","srcSet":"/static/0e6a2859511bc04abeba878c5508a73f/dd2c8/gatsby.webp 375w,\n/static/0e6a2859511bc04abeba878c5508a73f/c5e11/gatsby.webp 750w,\n/static/0e6a2859511bc04abeba878c5508a73f/f77da/gatsby.webp 1500w","sizes":"(min-width: 1500px) 1500px, 100vw"},"sources":[]},"width":1500,"height":1000}},"publicURL":"/static/0e6a2859511bc04abeba878c5508a73f/gatsby.jpg"}}}}]}},"pageContext":{"slug":"/posts/gatsby-page-route/","prev":{"node":{"fields":{"slug":"/posts/gatsby-request/"},"headings":[{"depth":2,"value":"GraphQL이란?"},{"depth":2,"value":"Gatsby에서 GraphQL을 사용하는 방법"}]}},"next":{"node":{"fields":{"slug":"/posts/Redux-useDispatch/"},"headings":[{"depth":2,"value":"state를 useDispatch로 보내기"},{"depth":2,"value":"순서"},{"depth":4,"value":"2. state를 raise하기 하기"}]}}}},"staticQueryHashes":[],"slicesMap":{}}